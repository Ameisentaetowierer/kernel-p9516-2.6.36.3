/* drivers/input/touchscreen/avago_ofn.c
 *
 * Copyright (C) 2010 Avago Technologies. 
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
#define DEBUG
#define DEBUG_SHOW_MOVE_INFO    0
#include <linux/module.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/spi/spi.h>
#include <linux/earlysuspend.h>
#include <linux/hrtimer.h>
#include <linux/platform_device.h>
//#include <linux/i2c.h>
#include <linux/delay.h>
#include "avago_ofn.h"
#include <linux/io.h>
#include <linux/gpio.h>
#include <mach/gpio.h>

#include <linux/time.h>
#include <linux/unistd.h>
#include <linux/delay.h>

#include <linux/mutex.h>		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
#include <asm/atomic.h>         // for overcome race condition
#include <linux/timer.h>

// [ASD2-ES1|Chris Yang|2010.12.06] thread
#include <linux/kthread.h>
#define CLICK_TIME 150000000
#define BILLION  1000000000L
enum doubleClick
{
    non, click_one,click_one_up,click_two,click_two_up, overTime
} ;

/* AVAGO_RESET will driver NRST pin low then high to reset the chip */
//#define AVAGO_RESET
#define AVAGO_GPIO_CONTROL_SHUTDOWN
#define AVAGO_DOME
//#define AVAGO_FPD
#define AVAGO_LED_CONTROL
//#define JACO_FPD_TEST
#define DOME_IRQ_MODE

#define EVENT_UP            KEY_F9
#define EVENT_DOWN          KEY_F10
#define EVENT_ONE_CLICK     KEY_HOME
#define EVENT_TWO_CLICK     KEY_F11
#define EVENT_LONG_PRESS    KEY_F12     //+++[ASD2_ES1|Jaco_Gao|2011.04.09] key-event for screenshot

#define EVENT_TEST_KEY_UP               KEY_A
#define EVENT_TEST_KEY_DOWN             KEY_B
#define EVENT_TEST_KEY_ONE_CLICK        KEY_C
#define EVENT_TEST_KEY_TWO_CLICK        KEY_E
#define EVENT_TEST_KEY_LONG_PRESS       KEY_D

//[ASD2-ES1|Soflen|2011.04.13] Test Mode
#define MODE_NORMAL     0
#define MODE_TEST       1

//[ASD2-ES1|Soflen|2011.04.18]
#define NO_EVENT_COUNT  5
#define SLOW_MOV_COUNT  2
#define FAST_MOV_COUNT  1
#define SLOW_MOV_DISTANCE   10  // ms
#define FAST_MOV_DISTANCE   20  // ms

#define OFN_GPIO_IN     1
#define OFN_GPIO_OUT    0
#define OFN_GPIO_HIGH   1
#define OFN_GPIO_LOW    0

#define ONE_CLICK_TIME_GAP_INIT         500     // 500 ms

#define FPD_POLL_TIME	        70 // 70ms

#define THIRTEEN_MA		        0
#define FORTY_MA			    1
#define FINGER_ON_THRESHOLD		12

#define I2C_M_WR				0
#define leswap(x) ( ((x << 8) & 0xff00) | ((x >> 8) & 0xff) )
#define MS_TO_NS(x) (x *1E6L)

// ADBM_A320 Register Addresses
#define ADBM_A320_PRODUCTID_ADDR         0x83
#define ADBM_A320_REVISIONID_ADDR        0x01     //0x00
#define ADBM_A320_MOTION_ADDR            0x02
#define ADBM_A320_DELTAX_ADDR            0x03
#define ADBM_A320_DELTAY_ADDR            0x04
#define ADBM_A320_SQUAL_ADDR             0x05
#define ADBM_A320_SHUTTERUPPER_ADDR      0x06
#define ADBM_A320_SHUTTERLOWER_ADDR      0x07
#define ADBM_A320_MAXIMUMPIXEL_ADDR      0x08
#define ADBM_A320_PIXELSUM_ADDR          0x09
#define ADBM_A320_MINIMUMPIXEL_ADDR      0x0A
#define ADBM_A320_PIXELGRAB_ADDR         0x0B
#define ADBM_A320_CRC0_ADDR              0x0C
#define ADBM_A320_CRC1_ADDR              0x0D
#define ADBM_A320_CRC2_ADDR              0x0E
#define ADBM_A320_CRC3_ADDR              0x0F
#define ADBM_A320_SELFTEST_ADDR          0x10
#define ADBM_A320_CONFIGURATIONBITS_ADDR 0x11
#define ADBM_A320_LED_CONTROL_ADDR       0x1A
#define ADBM_A320_IO_MODE_ADDR           0x1C
#define ADBM_A320_OBSERVATION_ADDR       0x2E
#define ADBM_A320_SOFTRESET_ADDR      	 0x3A     //0x5A
#define ADBM_A320_SHUTTER_MAX_HI_ADDR    0x3B
#define ADBM_A320_SHUTTER_MAX_LO_ADDR    0x3C
#define ADBM_A320_INVERSEREVISIONID_ADDR 0x3E     //0xFF
#define ADBM_A320_INVERSEPRODUCTID_ADDR  0x3F     //0x7C

typedef union
{
	uint16_t w;
	uint8_t b[2];
}
union16;

static struct workqueue_struct *avago_ofn_wq;

struct avago_ofn_platform_data {
	uint32_t version;
	int (*power)(int on);
};

struct avago_fpd_data {
	uint8_t motion2;
	uint8_t finger_on_counter;
	uint8_t finger_leave_counter;
	uint8_t FPD_turned_off;
	uint8_t shutter_values_captured;
	uint8_t last_state;
	uint16_t shutter_at_40ma;
	uint16_t shutter_at_13ma;
	uint8_t switch_led_counter;
};

#ifdef DOME_IRQ_MODE
enum click_status {
    NONE = 0,
    ONE_CLICK,
    TWO_CLICK,
    LONG_PRESS,
};
#endif
	
struct avago_ofn_data {
	struct spi_device *spi;
	struct input_dev *input_dev;
	int use_irq;
	uint8_t irq;
	struct hrtimer timer;
	struct hrtimer dome_timer;
	struct work_struct  work;
	int shutdown_gpio;
	int dome_gpio;
	int led_up_gpio;
	int led_down_gpio;

    int gpio_fpd;
    
	uint16_t dome_count;
	int motion_x;
	int motion_y;
	int motion_count;
	int key_pressed;
	int longMove;
	uint8_t fpd_support;
	struct avago_fpd_data fpd;

	int (*power)(int on);
	struct early_suspend early_suspend;

    int gpio_rst;

    #ifdef DOME_IRQ_MODE
    int irq_dome;
    unsigned long click_time_gap;                           // time gap control for 2-click, unit in ms.
    unsigned long long_press_time;                          // time control for long press, unit in ms.
    enum click_status dome_click_status;
    int gpio_dome;
    atomic_t dome_status;
    struct timer_list dome_irq_click_timer;
    #endif

    #ifdef JACO_FPD_TEST
    int irq_fpd;
    #endif

    //+++[ASD2_ES1|Jaco_Gao|2011.04.17] Flash LED via timer
    struct timer_list led_timer;
    enum {
        POWER_NONE = 0,
        POWER_ON,
        POWER_OFF,
    } led_action;
    int led_gpio_1;
    int led_gpio_2;
    unsigned long led_power_on_to_off_interval;             // unit in ms
    unsigned long led_power_off_to_on_interval;
    int led_multi;
    //---[ASD2_ES1|Jaco_Gao|2011.04.17] Flash LED via timer
    
};

/* define a globle for easy porting */
static int att_mode = MODE_NORMAL;

static unsigned char avago_keycode[] = {
    EVENT_UP,
    EVENT_DOWN,
    EVENT_ONE_CLICK,
    EVENT_TWO_CLICK,
    EVENT_LONG_PRESS,
    EVENT_TEST_KEY_UP,
    EVENT_TEST_KEY_DOWN,
    EVENT_TEST_KEY_ONE_CLICK,
    EVENT_TEST_KEY_TWO_CLICK,
    EVENT_TEST_KEY_LONG_PRESS,
};

#ifdef CONFIG_HAS_EARLYSUSPEND
static void avago_ofn_early_suspend(struct early_suspend *h);
static void avago_ofn_late_resume(struct early_suspend *h);
#endif
void outPutEvent(int,int,int,int,struct avago_ofn_data *);
int averageXY(int , int );

//+++[ASD2-ES1|Soflen|2011.04.13] OFN event detection
int mX, mY;
struct avago_ofn_data *mTs;
static struct task_struct *ofn_task;
u8 ofn_running = 0;
void eventType( int type, struct avago_ofn_data *ts );
//---[ASD2-ES1|Soflen|2011.04.13] OFN event detection

//+++ sysfs
u8 ofn_reg = 0;
int irq_status = 1;
int g_irq = 0;
static struct avago_ofn_data *g_ts;

static uint8_t avago_read_register_byte(struct spi_device *spi, u8 reg);
static int avago_write_register_byte(struct spi_device *spi, u8 reg, u8 val);
static int avago_init_ofn(struct avago_ofn_data *ts);

static ssize_t ofn_mode_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

	if(att_mode == MODE_NORMAL)
		sprintf(buf, "Current mode is normal mode.\n");
	else if (att_mode == MODE_TEST)
		sprintf(buf, "Current mode is test mode.\n");
		
	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_mode_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	char data[128];
	sscanf(buf, "%s", data);
	if(strcmp(data, "test") == 0)
	{
        att_mode = MODE_TEST;
		printk(KERN_ERR "enter test mode\n");
	}
	if(strcmp(data, "normal") == 0)
	{
		att_mode = MODE_NORMAL;
		printk(KERN_ERR "enter normal mode\n");
	}

	return count;
}

static ssize_t ofn_reg_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int ret = 0;
	sprintf( buf, "OFN Reg. 0x%02x = 0x%02x\n", ofn_reg, avago_read_register_byte(g_ts->spi, ofn_reg) );
	ret = strlen(buf)+1;
	return ret;
}

static ssize_t ofn_reg_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	sscanf(buf, "%d", (int*)&ofn_reg);
	pr_info("Set ofn_reg = 0x%02x", ofn_reg);
	return count;
}

static ssize_t ofn_irq_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

	if(irq_status)
		sprintf(buf, "Current irq is enabled.\n");
	else
		sprintf(buf, "Current irq is disabled.\n");

	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_irq_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	int val = 0;
	sscanf(buf, "%d", &val);

    switch( val )
    {
    case 0:
        disable_irq_nosync(g_irq);
        irq_status = 0;
    break;
    case 1:
        enable_irq(g_irq);
        irq_status = 1;
    break;
    default:
        return -EINVAL;
    }

	return count;
}

static ssize_t ofn_val_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    u8 val = 0;
    sscanf(buf, "%d", (int*)&val);
    avago_write_register_byte(g_ts->spi, ofn_reg, val);
    printk("OFN : write 0x%02x to Reg. 0x%02x\n", val, ofn_reg);
	return count;
}

static ssize_t ofn_reg_table_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
    int ret = 0;
    int i = 0;
    for( i = 0; i<= 0x77; i++)
        printk("Reg. 0x%02x = 0x%02x\n", i, avago_read_register_byte(g_ts->spi, i));

    return ret;
}

static ssize_t ofn_reset_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    switch( *buf )
    {
    case '0':
        gpio_set_value(g_ts->shutdown_gpio, 1);
        mdelay(150);        //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
    break;
    case '1':
        gpio_set_value(g_ts->shutdown_gpio, 0);
        mdelay(100);        //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
    break;
    case '2':
        avago_init_ofn(g_ts);
    break;
    default:
        return -EINVAL;
    }

	return count;
}

static ssize_t ofn_status_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
    int ret;
    sprintf( buf, "OFN status = 0x%02x\n", avago_read_register_byte(g_ts->spi, 2) );
    ret = strlen(buf) + 1;
    return ret;
}

//+++[ASD2_ES1|Jaco_Gao|2011.04.14] Add LED for test
static ssize_t ofn_led_up_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    int val;
	sscanf(buf, "%d", &val);
	if( val == 1 )
	{
        gpio_set_value( AVAGO_LED_UP, 1);
	}
    else
    {
        gpio_set_value( AVAGO_LED_UP, 0);
    }

	return count;
}

static ssize_t ofn_led_down_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    int val;
	sscanf(buf, "%d", &val);
	if( val == 1 )
	{
        gpio_set_value( AVAGO_LED_DOWN, 1);
	}
    else
    {
        gpio_set_value( AVAGO_LED_DOWN, 0);
    }

	return count;
}
//---[ASD2_ES1|Jaco_Gao|2011.04.14] Add LED for test

static DEVICE_ATTR(led_up, S_IWUGO , NULL, ofn_led_up_store);           //+++[ASD2_ES1|Jaco_Gao|2011.04.14] Add LED for test
static DEVICE_ATTR(led_down, S_IWUGO , NULL, ofn_led_down_store);       //+++[ASD2_ES1|Jaco_Gao|2011.04.14] Add LED for test
static DEVICE_ATTR(status, S_IRUGO , ofn_status_show, NULL);
static DEVICE_ATTR(reset, S_IWUGO , NULL, ofn_reset_store);
static DEVICE_ATTR(reg_table, S_IRUGO , ofn_reg_table_show, NULL);
static DEVICE_ATTR(val, S_IWUGO , NULL, ofn_val_store);
static DEVICE_ATTR(reg, S_IWUGO|S_IRUGO, ofn_reg_show, ofn_reg_store);
static DEVICE_ATTR(irq, S_IWUGO|S_IRUGO, ofn_irq_show, ofn_irq_store);

//[ASD2-ES1|Soflen|2011.04.13] Test mode
//static DEVICE_ATTR(mode, S_IRUSR | S_IRGRP | S_IROTH, ofn_mode_show, ofn_mode_store);
static DEVICE_ATTR(mode, 666, ofn_mode_show, ofn_mode_store);

static struct kobject *android_ofn_kobj;

static struct attribute *attributes[] = {
        &dev_attr_mode.attr,
        &dev_attr_irq.attr,
        &dev_attr_status.attr,
        &dev_attr_reset.attr,
        &dev_attr_reg.attr,
        &dev_attr_val.attr,
        &dev_attr_reg_table.attr,
        &dev_attr_led_up.attr,
        &dev_attr_led_down.attr,
        NULL,
};

static struct attribute_group attribute_group = {
    .attrs = attributes,
};

static int ofn_sysfs_init(void)
{
	int ret;
	android_ofn_kobj = kobject_create_and_add("ofn", NULL);
	if (android_ofn_kobj == NULL) {
		printk(KERN_ERR
		       "ofn_sysfs_init: subsystem_register failed\n");
		ret = -ENOMEM;
		goto err;
	}

	//ret = sysfs_create_file(android_ofn_kobj, &dev_attr_mode.attr);	//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	ret = sysfs_create_group( android_ofn_kobj, &attribute_group);		//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	if (ret) {
		printk(KERN_ERR
		       "touch_sysfs_init: sysfs_create_group failed\n");
		goto error;
	}
	return 0;
error:
	kobject_del(android_ofn_kobj);
err:
	return ret;
}
//--- sysfs

static uint8_t avago_read_register_byte(struct spi_device *spi, u8 reg)
{
	int ret;
	u8 val;
	u8 code = reg;

	ret = spi_write_then_read(spi, &code, 1, &val, 1);
    udelay(30);     //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
	if (ret < 0) {
		printk(KERN_ERR "spi read error reg:0x%X return:%d", reg, ret);
		return ret;
	}
	
	return val;
}

void inline avago_ofn_report_key(struct avago_ofn_data *pdata, u8 key)
{
    input_report_key(pdata->input_dev, key, 1);
    input_sync(pdata->input_dev);
    input_report_key(pdata->input_dev, key, 0);
    input_sync(pdata->input_dev);
}

void inline avago_ofn_report_key_val(struct avago_ofn_data *pdata, u8 key, int val)
{
    input_report_key(pdata->input_dev, key, val);
    input_sync(pdata->input_dev);
}

void inline avago_ofn_report_key_val_pressed(struct avago_ofn_data *pdata, u8 key, int val)
{
    avago_ofn_report_key_val(pdata, key, val);
    pdata->key_pressed = ((val == 1)? key : 0 );
}

void inline clear_pending_data( struct avago_ofn_data *ts )
{
    int x = 0;
    int y = 0;
    while(avago_read_register_byte(ts->spi, 2) & 0x80) {
		x = avago_read_register_byte(ts->spi, 3);
		y = avago_read_register_byte(ts->spi, 4);
        udelay(5);
    }
}

//+++[ASD2_ES1|Jaco_Gao|2011.04.18] Flash led by timer
void inline avago_flash_led_up( struct avago_ofn_data *ts,
    unsigned long on_to_off,
    unsigned long off_to_on)
{
    if( timer_pending( &ts->led_timer ) )
        return;
    ts->led_power_on_to_off_interval = on_to_off;
    ts->led_power_off_to_on_interval = off_to_on;
    ts->led_gpio_1 = AVAGO_LED_UP;
    ts->led_gpio_2 = 0;
    ts->led_action = POWER_OFF;
    ts->led_multi = 0;
    gpio_set_value(ts->led_gpio_1, 1);
    mod_timer(&ts->led_timer, jiffies+ts->led_power_on_to_off_interval*HZ/1000);
}
void inline avago_flash_led_down( struct avago_ofn_data *ts,
    unsigned long on_to_off,
    unsigned long off_to_on)
{
    if( timer_pending( &ts->led_timer ) )
        return;
    ts->led_power_on_to_off_interval = on_to_off;
    ts->led_power_off_to_on_interval = off_to_on;
    ts->led_gpio_1 = AVAGO_LED_DOWN;
    ts->led_gpio_2 = 0;
    ts->led_action = POWER_OFF;
    ts->led_multi = 0;
    gpio_set_value(ts->led_gpio_1, 1);
    mod_timer(&ts->led_timer, jiffies+ts->led_power_on_to_off_interval*HZ/1000);
}

void inline avago_flash_led( struct avago_ofn_data *ts,
    unsigned long on_to_off,
    unsigned long off_to_on)
{
    if( timer_pending( &ts->led_timer ) )
        return;
    ts->led_power_on_to_off_interval = on_to_off;
    ts->led_power_off_to_on_interval = off_to_on;
    ts->led_gpio_1 = AVAGO_LED_UP;
    ts->led_gpio_2 = AVAGO_LED_DOWN;
    ts->led_action = POWER_OFF;
    ts->led_multi = 0;
    gpio_set_value(ts->led_gpio_1, 1);
    gpio_set_value(ts->led_gpio_2, 1);
    mod_timer(&ts->led_timer, jiffies+ts->led_power_on_to_off_interval*HZ/1000);
}

void inline avago_flash_led_multi( struct avago_ofn_data *ts,
    unsigned long on_to_off,
    unsigned long off_to_on,
    int times)
{
    if( timer_pending( &ts->led_timer ) )
        return;
    ts->led_power_on_to_off_interval = on_to_off;
    ts->led_power_off_to_on_interval = off_to_on;
    ts->led_gpio_1 = AVAGO_LED_UP;
    ts->led_gpio_2 = AVAGO_LED_DOWN;
    ts->led_action = POWER_OFF;
    ts->led_multi = (times << 2);
    gpio_set_value(ts->led_gpio_1, 1);
    gpio_set_value(ts->led_gpio_2, 1);
    mod_timer(&ts->led_timer, jiffies+ts->led_power_on_to_off_interval*HZ/1000);
}
//---[ASD2_ES1|Jaco_Gao|2011.04.18] Flash led by timer

static int avago_write_register_byte(struct spi_device *spi, u8 reg, u8 val)
{
	int ret_val;
	unsigned char buf[2];

	/* MSB must be '1' to indicate write */
	buf[0] = reg | 0x80;
	buf[1] = val;
	ret_val = spi_write_then_read(spi, buf, 2, NULL, 0);
    udelay(30);     //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
	if(ret_val < 0)
	{
		printk(KERN_ERR "spi write error reg:0x%X return:%d", reg, ret_val);
	}
	return ret_val;
}

static int avago_init_ofn(struct avago_ofn_data *ts)
{
	int ret = 0;
	
	/* Perform soft reset by writing 0x5A to address 0x3A */
	avago_write_register_byte(ts->spi, 0x3A, 0x5A);
	mdelay(23);     //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
	/* init as datasheet required 
	Write 0xE4 to address 0x60.
	Set Speed Switching, write 0x62 with 0x12, 0x63 with 0x0E, 0x64 with 0x08, 0x65 with 0x06, 0x66 with 0x40, 0x67 with 0x08, 
		0x68 with 0x48, 0x69 with 0x0A, 0x6A with 0x50, 0x6B with 0x48.
	Set Assert/De-assert, write 0x6D with 0xC4, 0x6E with 0x34, 0x6F with 0x3C, 0x70 with 0x18, 0x71 with 0x20.
	Set Finger Presence Detection threshold, write 0x75 with 0x50.
	IF XY Quantization is used, then write 0x73 with 0x99 and 0x74 with 0x02.
	Write 0x10 to register 0x1C. This will activate Burst mode. If Burst mode not used then skip this step.
	Read from registers 0x02, 0x03 and 0x04 (or read these same 3 bytes with Burst mode) one time
	*/
	//avago_write_register_byte(ts->spi, 0x60, 0xE4);
	avago_write_register_byte(ts->spi, 0x60, 0xF4); 	/* enable quatitation */
	
	avago_write_register_byte(ts->spi, 0x62, 0x12);
	avago_write_register_byte(ts->spi, 0x63, 0x01); // YCC
	avago_write_register_byte(ts->spi, 0x64, 0x08);
	avago_write_register_byte(ts->spi, 0x65, 0x06);
	avago_write_register_byte(ts->spi, 0x66, 0x40);
	avago_write_register_byte(ts->spi, 0x67, 0x08);
	avago_write_register_byte(ts->spi, 0x68, 0x48);
	avago_write_register_byte(ts->spi, 0x69, 0x0A);
	avago_write_register_byte(ts->spi, 0x6A, 0x50);
	avago_write_register_byte(ts->spi, 0x6B, 0x48);
	
	avago_write_register_byte(ts->spi, 0x6D, 0xC4);
	avago_write_register_byte(ts->spi, 0x6E, 0x34);
	avago_write_register_byte(ts->spi, 0x6F, 0x3C);
	avago_write_register_byte(ts->spi, 0x70, 0x18);
	avago_write_register_byte(ts->spi, 0x71, 0x20);
	
	avago_write_register_byte(ts->spi, 0x75, 0x50);
	
	avago_write_register_byte(ts->spi, 0x73, 0x99);
	avago_write_register_byte(ts->spi, 0x74, 0x02);
	
	avago_read_register_byte(ts->spi, 0x2);
	avago_read_register_byte(ts->spi, 0x3);
	avago_read_register_byte(ts->spi, 0x4);

	ts->motion_count = 0;
	ts->motion_x = 0;
	ts->motion_y = 0;
	ts->key_pressed = 0;

	return ret;
}


static int init_fpd(struct avago_ofn_data *ts)
{
	struct avago_fpd_data *fpd;

	fpd = &ts->fpd;

	fpd->motion2 = 0;
	fpd->finger_on_counter = 0;
	fpd->finger_leave_counter = 0;
	fpd->FPD_turned_off = 0;
	fpd->shutter_values_captured = 0;
	fpd->last_state = THIRTEEN_MA;
	fpd->shutter_at_40ma = 0;
	fpd->shutter_at_13ma = 0;
	fpd->switch_led_counter = 0;

	return 0;
}
#ifdef AVAGO_FPD
static int switch_led_driving(struct avago_ofn_data *ts)
{
	struct avago_fpd_data *fpd;	
	union16 shutter1;

	fpd = &ts->fpd;
/*	
		// Once FPD is off, make sensor operate in 9.6mA. (~10mA)
		if (fpd->FPD_turned_off == 1)
		{	//force current during future navigation to be in 13mA
			//spi_write_sensor(0x1a,0x00);
			avago_write_register_byte(ts->spi, 0x1a, 0x00);

			fpd->last_state = THIRTEEN_MA;
			fpd->FPD_turned_off = 0;
			return 0;

		}
*/		
		//if ( (time_15 == 0) && (time_99 == 0) && (led_switching_start == 1) )
		{	// time_15 is the main timer for this loop.
			// time_99 is the timer for motion loop. This variable will gate this loop so that it 
			// will not start provided enough time has passed after there is no motion.
			//
			// [led_switching_start] : variable to keep track whether LED driving current 
			// switching is required. 
			// - When finger is moving, don't switch
			// - When finger is not moving, switching after time_99,
			// - When FPD is off, don't switch

			// read the shutter values
			//shutter1.b[0] = spi_read_sensor(ADBM_A320_SHUTTERUPPER_ADDR);
			//shutter1.b[1] = spi_read_sensor(ADBM_A320_SHUTTERLOWER_ADDR);
			shutter1.b[1] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERUPPER_ADDR);
			shutter1.b[0] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERLOWER_ADDR);
			//printk(KERN_INFO "shutter = %x \n", shutter1.w);
			
            		// If the last state is 40mA, switch to 13mA driving current
			if (fpd->last_state == FORTY_MA)
			{
				fpd->shutter_at_40ma = shutter1.w;
				//spi_write_sensor(0x1a,0x00);
				avago_write_register_byte(ts->spi, 0x1a, 0x00);
				fpd->last_state = THIRTEEN_MA;
			}

			// If the last state is 13mA, switch to 40mA driving current
			else if ( fpd->last_state == THIRTEEN_MA )
			{
				fpd->shutter_at_13ma = shutter1.w;
                		//spi_write_sensor(0x1a,0x03);
				avago_write_register_byte(ts->spi, 0x1a, 0x03);
				fpd->last_state = FORTY_MA;
			}

			// compare shutter ratio. uses *10 to take away decimal point comparison.
			// shutter_ratio = shutter_at_40ma *10 /shutter_at_13ma ;
			fpd->shutter_values_captured++;

			// fail safe check
			if (fpd->shutter_values_captured > 5)
			{ 
				fpd->shutter_values_captured = 0;
			}

		}

	return 0;
}
#endif

//+++[Soflen]
static int ofn_key_thread(void *nothing)
{
    int empty = 0;
    int counter = 0;
    int y = mY;

    ofn_running = 1;
	do {
        msleep(10);
        if (mY == 0) {   // means no more input
            empty++;
            if (empty > NO_EVENT_COUNT) {
                if ((counter >= SLOW_MOV_COUNT && y > SLOW_MOV_DISTANCE) || (counter == FAST_MOV_COUNT && y > FAST_MOV_DISTANCE)) {
                    eventType(4, mTs);
                }
                else if ((counter >= SLOW_MOV_COUNT && y < -SLOW_MOV_DISTANCE) || (counter == FAST_MOV_COUNT && y < -FAST_MOV_DISTANCE)) {
                    eventType(3, mTs);
                }
                ofn_running = 0;
                mY = 0;
                clear_pending_data(mTs);
                return 0;
            }
        }
        else {
            empty = 0;
            if ((y >= 0 && mY >= 0) || (y < 0 && mY < 0)) {   // Same motion
                y += mY;
                mY = 0;
            }
            else {  // Inverse motion
                if ((counter >= SLOW_MOV_COUNT && y > SLOW_MOV_DISTANCE) || (counter == FAST_MOV_COUNT && y > FAST_MOV_DISTANCE)) {
                    eventType(4, mTs);
                }
                else if ((counter >= SLOW_MOV_COUNT && y < -SLOW_MOV_DISTANCE) || (counter == FAST_MOV_COUNT && y < -FAST_MOV_DISTANCE)) {
                    eventType(3, mTs);
                }
                y = mY;
                mY = 0;
                counter = 0;
                clear_pending_data(mTs);
            }
            counter++;
        }
	} while (!kthread_should_stop());

    mY = 0;
    ofn_running = 0;
    clear_pending_data(mTs);
	return 0;
}
//---[Soflen]

static void avago_ofn_work_func(struct work_struct *work)
{
    //[ASD2_ES1|Jaco_Gao|2011.03.02] Fix warning in building
    #if 0
	//int ret;
	char x, y, tempx, tempy;
	struct avago_ofn_data *ts = container_of(work, struct avago_ofn_data, work);
	uint8_t status, shutter_ratio;
	uint8_t pix_min, pix_max, squal;
	union16 shutter1;
	struct avago_fpd_data *fpd = &ts->fpd;
    #else
	char x, y;
    int X, Y;
	struct avago_ofn_data *ts = container_of(work, struct avago_ofn_data, work);
	uint8_t status;
    #endif
    //[ASD2_ES1|Jaco_Gao|2011.03.02] Fix warning in building

	/* release the key */
	if(ts->key_pressed)
	{
        avago_ofn_report_key_val_pressed(ts, ts->key_pressed, 0);
		//ts->key_pressed = 0;
	}

    #if 0
    #ifdef AVAGO_DOME
	/* handle dome(single click/ long press) */
	if(ts->dome_count == 0)
	{
		if(!gpio_get_value(ts->dome_gpio))
		{
			ts->dome_count ++;
			printk(KERN_INFO "dome gpio down, count = %d\n", ts->dome_count);
            
			/* start timer, now is 5ms, adjust it for debounce */
			hrtimer_start(&ts->dome_timer, ktime_set(0, MS_TO_NS(5)), HRTIMER_MODE_REL);
			goto end_of_work_func;
		}
	}
	else
	{
		/* let timer handle dome function */
        return;
        //goto end_of_work_func;
	}
    #endif // AVAGO_DOME
    #endif

    status = avago_read_register_byte(ts->spi, 2);
	//printk(KERN_ERR "motion = %x \n", status);
    #ifdef AVAGO_FPD
    // Once FPD is off, make sensor operate in 9.6mA. (~10mA)
    if (fpd->FPD_turned_off == 1)
    {
        //force current during future navigation to be in 13mA
        //spi_write_sensor(0x1a,0x00);
        avago_write_register_byte(ts->spi, 0x1a, 0x00);

        fpd->last_state = THIRTEEN_MA;
        fpd->FPD_turned_off = 0;
    }

	fpd->motion2 = status;
	// motion2 is a variable to keep previously known FPD state in IC.		
	if((fpd->motion2 & 0x01) && (fpd->finger_on_counter < FINGER_ON_THRESHOLD) )
	{

		fpd->switch_led_counter++;
		if(fpd->switch_led_counter == 2)
		{
			switch_led_driving(ts);
			fpd->switch_led_counter = 0;
		}

		// method 1: change driving current
		if(fpd->shutter_values_captured == 2)
		{
			// Once two shutter values are captured, ratio of the two
			// can be compared to check for presence of a reflective surface
			shutter_ratio = fpd->shutter_at_40ma *10/fpd->shutter_at_13ma ;
			//printk(KERN_INFO "shutter_ratio = %d \n", shutter_ratio);

			if ( (shutter_ratio > 7) && (shutter_ratio < 14) )
			{	// if LED shutter value is between 0.9 and 1.2, 
				fpd->motion2 = fpd->motion2 & 0xFE;
				printk(KERN_INFO "shutter_ratio = %d \n", shutter_ratio);
			/*
			FPD_turned_off = 1;				// set FPD off flag
			L5 = !(motion2 & 0x01);			// show FPD status on LED
			finger_leave_counter2 = 0;
			finger_on_counter = 0;
			free_scroll = 0;	// Stop free scrolling mode if applicable
			*/
			}
			fpd->shutter_values_captured = 0;		// reset counter so shutter values can be recaptured.
		}

		// method 2
		squal   = avago_read_register_byte(ts->spi, ADBM_A320_SQUAL_ADDR);
		pix_min = avago_read_register_byte(ts->spi, ADBM_A320_MINIMUMPIXEL_ADDR);
		pix_max = avago_read_register_byte(ts->spi, ADBM_A320_MAXIMUMPIXEL_ADDR);
		shutter1.b[1] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERUPPER_ADDR);
		shutter1.b[0] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERLOWER_ADDR);
		// shutter1.b[0] is lower byte of a 16 bit unsigned integer
		// shutter1.b[0] is upper byte of a 16 bit unsigned integer
		// shutter1.w is the combined 16 bit unsigned integer.
		//printk(KERN_INFO "squal = %x %x %x %x \n", squal, pix_min, pix_max, shutter1.w);
		
		//fpd->motion2 = status;
		//printk(KERN_ERR "motion = %x \n", status);

		// A comparison is done here to check is squal value is low (means finger is off),
		// If pix_max - pix_min is high, it tends to mean a strong external light source (point source) 
		// is present.
		// if shutter is low, it tends to mean an external light is shining directly into the sensor, 
		// and light reflected from sensor's LED cannot produce so might light.
		if ( (abs(pix_max - pix_min) > 230) || (squal < 15) || (shutter1.w < 25) )
		{	
			// finger_leave_counter is built in to reduce hysteresis effects
			// while finger is navigation smoothly, FPD may sometimes gets deactivated,
			// this reduces it. 
			if (fpd->finger_leave_counter >= 4)
			{	// finger_leave_counter is built in to reduce hysteresis effects
				// while finger is navigation smoothly, FPD may sometimes gets deactivated,
				// this reduces it. 
				printk(KERN_INFO "finger_leave_counter = %d \n", fpd->finger_leave_counter);

				fpd->motion2 = fpd->motion2 & 0xFE;
				/*
				FPD_turned_off = 1;
				finger_leave_counter = 0;
				finger_on_counter = 0; // reset finger on counter
				free_scroll = 0;	// Stop free scrolling mode if applicable
				*/
			}
			else
			{
				fpd->finger_leave_counter++;
			}

		}

		fpd->finger_on_counter++;
		//printk(KERN_INFO "fpd->finger_on_counter = %d \n", fpd->finger_on_counter);
		if (fpd->finger_on_counter == FINGER_ON_THRESHOLD) // 125 x 8ms = 1000ms
		{
			printk(KERN_INFO "finger on....\n\n");
			// ToDo
			// Light the led here to indicate finger touch
		}
		if (fpd->finger_on_counter > 150)
		{ fpd->finger_on_counter = 149;}
	}

    if((fpd->motion2 & 0x01) == 0)
    {
        if(fpd->finger_on_counter >= FINGER_ON_THRESHOLD)
        {
            printk(KERN_INFO "......finger off......\n\n");
            // ToDo
            // Turn off  the led here to indicate finger off
        }
        init_fpd(ts);
        fpd->FPD_turned_off = 1;
    }
    #endif // AVAGO_FPD

	if(status & 0x80)
	{
		//+++[ASD2-ES1|Soflen|2011.04.13] OFN event detection
		x = avago_read_register_byte(ts->spi, 3);
		y = avago_read_register_byte(ts->spi, 4);

        x &= 0x00FF;
        y &= 0x00FF;
        if ( x > 127 )
            X = x - 256;
        else
            X = x;
        if ( y > 127 )
            Y = y - 256;
        else
            Y = y;
        
        mTs = ts;
        if (ofn_running == 0 && Y != 0 && mY == 0) {
            mY = Y;
            ofn_task = kthread_run(ofn_key_thread, NULL, "kofn");
            if (IS_ERR(ofn_task))
                pr_err("ERROR!!! Failed to start kofn\n");
        }
        else
            mY += Y;
        //---[ASD2-ES1|Soflen|2011.04.13] OFN event detection
    }

    clear_pending_data(ts);
    
    if( ts->use_irq )
        enable_irq(ts->irq);
}
void eventType( int type, struct avago_ofn_data *ts )
{
    switch ( type )
    {
    case 3 :
        if (att_mode == MODE_TEST)
            avago_ofn_report_key_val_pressed(ts, EVENT_TEST_KEY_UP, 1);
        else
            avago_ofn_report_key_val_pressed(ts, EVENT_UP, 1);

        avago_ofn_report_key_val_pressed(ts, ts->key_pressed, 0);
        #if DEBUG_SHOW_MOVE_INFO
        pr_info("case 3  longMove = %d \n", ts->longMove) ;
        #endif
        ts->longMove = 3 ;

        avago_flash_led_up(ts, 50, 0);

        ts->motion_x = 0 ;
        ts->motion_y = 0 ;
        ts->motion_count = 3 ;
    break ;

    case 4 :
        if (att_mode == MODE_TEST)
            avago_ofn_report_key_val_pressed(ts, EVENT_TEST_KEY_DOWN, 1);
        else
            avago_ofn_report_key_val_pressed(ts, EVENT_DOWN, 1);

        avago_ofn_report_key_val_pressed(ts, ts->key_pressed, 0);
        #if DEBUG_SHOW_MOVE_INFO
        printk("case 4  longMove = %d \n", ts->longMove) ;
        #endif
        ts->longMove = 4 ;

        avago_flash_led_down(ts, 50, 0);

        ts->motion_x = 0 ;
        ts->motion_y = 0 ;
        ts->motion_count = 3 ;
    break ;     // break for case 4:
    }
}

void outPutEvent(int count , int totalMotion , int x , int y , struct avago_ofn_data *ts )
{
    //+++[ASD2-ES1|Chris Yang|2010.12.22] remove x scale
    //int tempx = averageXY( count , x );
    int tempy = averageXY( count , y );

    #if 0
    if ( tempx >= (totalMotion  ))
    {
        if ( x & 0x80 )
        {
            eventType(1, ts );
        }
        else
        {
            eventType(2, ts );
        }
    }
    #endif
    //---[ASD2-ES1|Chris Yang|2010.12.22] remove x scale
    #if DEBUG_SHOW_MOVE_INFO
    pr_info("%s: tempy =  %d , totolMotion+2 = %d\n", __func__, tempy, (totalMotion+2));
    #endif
    if ( tempy >= ( totalMotion+2 ) )
    {
        if ( y & 0x80 )
        {
            eventType(3, ts );
        }
        else
        {
            eventType(4, ts );
        }
    }
    //ts->motion_count = 0;
} // end outPutEvnet

int averageXY(int count, int x)
{
    int tempx ;

    if( x & 0x80 )
        tempx = (0x100 - (x & 0xff)) & 0xff;
    else
        tempx = x & (0xff) ;
        // tempx = x;
    #if DEBUG_SHOW_MOVE_INFO
    pr_info("tempx = %d , count = %d  , tempx/=count = %d \n ", tempx,count,tempx/count);
    #endif
    tempx /= count ;
    return  tempx;

}

static enum hrtimer_restart avago_ts_timer_func(struct hrtimer *timer)
{
	struct avago_ofn_data *ts = container_of(timer, \
					struct avago_ofn_data, timer);
	queue_work(avago_ofn_wq, &ts->work);

	/* 8ms timer */
	hrtimer_start(&ts->timer, ktime_set(0, MS_TO_NS(8)), HRTIMER_MODE_REL);
	return HRTIMER_NORESTART;
}

#ifndef DOME_IRQ_MODE
static enum hrtimer_restart avago_dome_timer_func(struct hrtimer *timer)
{
	char gpio_value;
	struct avago_ofn_data *ts = container_of(timer, \
					struct avago_ofn_data, dome_timer);

	gpio_value = gpio_get_value(ts->dome_gpio);
	printk(KERN_INFO "gpio = %d, count = %d\n", gpio_value, ts->dome_count);

	if(gpio_value)
	{
		/* dome up, send report to upper layer */
		if(ts->dome_count == 1)
		{
			/* the first timer is 5ms to detect debouncing */
			printk(KERN_INFO "debounceing, gpio = %d\n", gpio_value);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
		else if(ts->dome_count <= DOME_SINGLE_CLICK_COUNT) //6
		{
			/* single click */
			if (att_mode == MODE_TEST) {
				input_report_key(ts->input_dev, KEY_A, 1);
				ts->key_pressed = KEY_A;
			}
			else {
				input_report_key(ts->input_dev, KEY_HOME, 1);
				ts->key_pressed = KEY_HOME;
			}

			printk(KERN_ERR "single click, count = %d\n", ts->dome_count);
									
			input_sync(ts->input_dev);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
		else if(ts->dome_count <= DOME_LONG_PRESS_COUNT) //21
		{
			/* long press */
			if (att_mode == MODE_TEST) {
				input_report_key(ts->input_dev, KEY_B, 1);
				ts->key_pressed = KEY_B;
			}
			else {
				input_report_key(ts->input_dev, KEY_MENU, 1);
				ts->key_pressed = KEY_MENU;
			}
			
			printk(KERN_ERR "long press, count = %d\n", ts->dome_count);
									
			input_sync(ts->input_dev);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
		else
		{
			printk(KERN_ERR "more than 2s, count = %d\n", ts->dome_count);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
	}
	else
	{
		/* dome down, increase the counter */
		if(ts->dome_count < 0x80)	/* set the max value to avoid overflow */
			ts->dome_count++;
	}
		

	/* 100ms timer */
	hrtimer_start(&ts->dome_timer, ktime_set(0, MS_TO_NS(100)), HRTIMER_MODE_REL);
	return HRTIMER_NORESTART;
}
#endif

static irqreturn_t avago_ts_irq_handler(int irq, void *dev_id)
{
	struct avago_ofn_data *ts = dev_id;
    //pr_info("+%s\n",__func__);
	//disable_irq(ts->irq);                 //[ASD2_ES1|Jaco_Gao|2011.03.02] fix for interrupt
    disable_irq_nosync(ts->irq);          //[ASD2_ES1|Jaco_Gao|2011.03.16] Disable irq before work function complete
    //udelay(1);      // add 1 us for safe time gap
    queue_work(avago_ofn_wq, &ts->work);
    //pr_info("-%s\n",__func__);
	return IRQ_HANDLED;
}

//+++[ASD2_ES1|Jaco_Gao|2011.04.08] TOUCH# in IRQ mode for FPD
#ifdef JACO_FPD_TEST
static irqreturn_t avago_ts_irq_fpd_handler(int irq, void *dev_id)
{
	//struct avago_ofn_data *ts = dev_id;
    pr_info("%s\n", __func__);
	return IRQ_HANDLED;
}
#endif
//---[ASD2_ES1|Jaco_Gao|2011.04.08] TOUCH# in IRQ mode for FPD

//+++[ASD2_ES1|Jaco_Gao|2011.04.08] DOME in IRQ mode
#ifdef  DOME_IRQ_MODE
static irqreturn_t avago_ts_irq_dome_handler(int irq, void *dev_id)
{
    struct avago_ofn_data *ts = dev_id;
    pr_info("%s\n", __func__);
    switch( (enum click_status)atomic_read(&ts->dome_status) )
    {
    case NONE :
        //ts->dome_click_status = ONE_CLICK;
        atomic_set( &ts->dome_status, ONE_CLICK);

        //ts->dome_irq_click_timer.expires = jiffies + HZ*3/10;
        //add_timer(&ts->dome_irq_click_timer);
        mod_timer(&ts->dome_irq_click_timer, jiffies + HZ*3/10);

    break;
    case ONE_CLICK :
        // detect two-click
        //ts->dome_click_status = TWO_CLICK;
        atomic_set( &ts->dome_status, TWO_CLICK);
    break;    
    default :
        pr_err("%s:Warring : unexpected click status %d\n", __func__,
                (enum click_status)atomic_read(&ts->dome_status));
        //ts->dome_click_status = NONE;
        atomic_set( &ts->dome_status, NONE);
        return IRQ_HANDLED;
    }
    return IRQ_WAKE_THREAD;
}

static irqreturn_t avago_ts_irq_dome_thread(int irq, void *dev_id)
{
    struct avago_ofn_data *ts = dev_id;
    pr_info("%s\n", __func__);

    switch( (enum click_status)atomic_read(&ts->dome_status) )
    {
    case NONE :
    break;
    case ONE_CLICK :
        // start timer to detect one-click
    break;
    case TWO_CLICK :
        //avago_ofn_report_key(ts, EVENT_TWO_CLICK);
    break;
    default:
        pr_err("%s:unexpected status %d\n", __func__, atomic_read(&ts->dome_status));
        //ts->dome_click_status = NONE;
        atomic_set(&ts->dome_status, NONE);
    break;
    }
    clear_pending_data(ts);
    return IRQ_HANDLED;
}

static void avago_dome_irq_timer_func_click(unsigned long arg)
{
    struct avago_ofn_data *ts = (struct avago_ofn_data *)arg;

    pr_info("%s\n", __func__);

    switch( (enum click_status)atomic_read(&ts->dome_status) )
    {
    case NONE :
        //ts->dome_click_status = ONE_CLICK;
    break;
    case ONE_CLICK :
        // Get status of DOME pin.
        // Low state for long press situation, then
        // add timer to confirm state again after a
        // specified timer.
        if( !gpio_get_value( ts->gpio_dome ) )
        {
            //mod_timer(&ts->dome_irq_click_timer, HZ*3);
            //ts->dome_irq_click_timer.expires = jiffies + HZ*2;
            //add_timer(&ts->dome_irq_click_timer);
            mod_timer(&ts->dome_irq_click_timer, jiffies + HZ*2);
            atomic_set(&ts->dome_status, LONG_PRESS);
        }
        else
        {
            // report 1-click
            //ts->dome_click_status = NONE;
            atomic_set(&ts->dome_status, NONE);
            if (att_mode == MODE_TEST)
                avago_ofn_report_key(ts, EVENT_TEST_KEY_ONE_CLICK);
            else
                avago_ofn_report_key(ts, EVENT_ONE_CLICK);
            avago_flash_led(ts, 100, 0);
        }
    break;
    case TWO_CLICK :
        //ts->dome_click_status = NONE;
        atomic_set( &ts->dome_status, NONE);
    break;
    case LONG_PRESS :
        // report 1-click / long-press ?
        atomic_set(&ts->dome_status, NONE);
        if( gpio_get_value(ts->gpio_dome) )
        {
            if (att_mode == MODE_TEST)
                avago_ofn_report_key(ts, EVENT_TEST_KEY_ONE_CLICK);
            else
                avago_ofn_report_key(ts, EVENT_ONE_CLICK);
        }
        else
        {
            if (att_mode == MODE_TEST)
                avago_ofn_report_key(ts, EVENT_TEST_KEY_LONG_PRESS);
            else
                avago_ofn_report_key(ts, EVENT_LONG_PRESS);
        }
        avago_flash_led(ts,100,0);
    break;
    default :
        pr_err("%s:unexpected status %d\n", __func__, atomic_read(&ts->dome_status));
        //ts->dome_click_status = NONE;
        atomic_set( &ts->dome_status, NONE);
    break;
    }
}

void avago_ofn_init_irq_dome_timer( struct avago_ofn_data *ts)
{
    init_timer(&ts->dome_irq_click_timer);
	ts->dome_irq_click_timer.data = (unsigned long) ts;
	ts->dome_irq_click_timer.function = avago_dome_irq_timer_func_click;
}
#endif
//---[ASD2_ES1|Jaco_Gao|2011.04.08] DOME in IRQ mode

//+++[ASD2_ES1|Jaco_Gao|2011.04.17] Flash LED via timer
static void avago_led_timer_func(unsigned long arg)
{
    struct avago_ofn_data *ts = (struct avago_ofn_data *)arg;

    switch( ts->led_action )
    {
    case POWER_ON:
        if( ts->led_gpio_1 > 0 )
            gpio_set_value(ts->led_gpio_1, 1);
        if( ts->led_gpio_2 > 0 )
            gpio_set_value(ts->led_gpio_2, 1);
    break;
    case POWER_OFF:
        if( ts->led_gpio_1 > 0 )
            gpio_set_value(ts->led_gpio_1, 0);
        if( ts->led_gpio_2 > 0 )
            gpio_set_value(ts->led_gpio_2, 0);
    break;
    default:
    break;
    }
    if ( ts->led_multi-- > 0 )
    {
        // set next action
        ts->led_action = ( (ts->led_action == POWER_ON)? POWER_OFF : POWER_ON );
        // set up next timer
        mod_timer( &ts->led_timer,
                    ((ts->led_action == POWER_OFF )? ts->led_power_on_to_off_interval : ts->led_power_off_to_on_interval));
        //add_timer( &ts->led_timer);
    }
    else
    {
        // clear timer parameter
        ts->led_action = POWER_NONE;
        ts->led_gpio_1 = 0;
        ts->led_gpio_2 = 0;
    }
}

void avago_ofn_init_led_timer( struct avago_ofn_data *ts )
{
    init_timer(&ts->led_timer);
	ts->led_timer.data = (unsigned long) ts;
	ts->led_timer.function = avago_led_timer_func;

    ts->led_gpio_1 = 0;
    ts->led_gpio_2 = 0;
    ts->led_action = POWER_NONE;
}
//---[ASD2_ES1|Jaco_Gao|2011.04.17] Flash LED via timer

//+++[ASD2_ES1|Jaco_Gao|2011.04.08] re-write GPIO init function
// description :
// in : OFN_GPIO_IN , OFN_GPIO_OUT
// stat : OFN_GPIO_HIGH , OFN_GPIO_LOW
// gpio_in_ts : record gpio declaration in ts, can be NULL
// ( NULL means not to store )
int inline avago_init_gpio( struct avago_ofn_data *ts, int gpio, const char* name, int in, int stat, int *gpio_in_ts)
{
    int ret;
    
	ret = gpio_request(gpio, name);
	if (ret < 0) {
		printk("%s : failed to request GPIO %d , %s\n", __func__, gpio, name);
        if( gpio_in_ts )
            *gpio_in_ts = 0;
        return ret;
	}
    printk("%s : request GPIO %s\n", __func__, name);
	ret = ((in == OFN_GPIO_IN )? gpio_direction_input(gpio) : gpio_direction_output(gpio, stat));
	if (ret < 0) {
        printk("%s: fail to direct GPIO %d , %s, to %s\n", __func__,
                gpio, name, ((in==OFN_GPIO_IN)?"input":"output"));
		gpio_free(gpio);
        if( gpio_in_ts )
            *gpio_in_ts = 0;
        return ret;
	}
    if( gpio_in_ts )
        *gpio_in_ts = gpio;

    return 0;
}
//---[ASD2_ES1|Jaco_Gao|2011.04.08] re-write GPIO init function

static int __devinit avago_ofn_probe(struct spi_device *spi)
{
	struct avago_ofn_data *ts;
	int ret = 0, gpio, i;
//	struct avago_ofn_platform_data *pdata;

	printk(KERN_ERR "%s : init avago ofn\n", __func__);
	spi->bits_per_word = 8;
	spi->mode = SPI_MODE_3;
	if (spi_setup(spi) < 0) {
		printk(KERN_ERR "%s : init SPI failed.\n", __func__);
		ret = -ENODEV;
	}
	pr_info("%s : spi setup done\n",__func__);
	ts = kzalloc(sizeof(struct avago_ofn_data), GFP_KERNEL);
	if (ts == NULL) {
		ret = -ENOMEM;
		goto err_alloc_data_failed;
	}
	INIT_WORK(&ts->work, avago_ofn_work_func);

	ts->spi = spi;
	ts->irq = spi->irq;
	g_irq =  ts->irq;			//+++[ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	dev_set_drvdata(&spi->dev, ts);

    #if 0       // This block is commented in original version
	pdata = spi->dev.platform_data;
	if (pdata) {
		ts->power = pdata->power;
	}
	if (ts->power) {
		ret = ts->power(1);
		msleep(10);
		if (ret < 0) {
			printk(KERN_ERR "avago_ofn_probe power on failed\n");
			goto err_power_failed;
		}
	}
    #endif
    
    //+++[ASD2_ES1|Jaco_Gao|2011.04.08] re-write GPIO init function
    ts->gpio_rst = 0;
    ts->dome_gpio = 0;
    ts->dome_count = 0;
    ts->led_up_gpio = 0;
    ts->led_down_gpio = 0;
    ts->gpio_fpd = 0;
    ts->shutdown_gpio = 0;
    
    #ifdef AVAGO_RESET
    if ( avago_init_gpio(ts, AVAGO_RESET_GPIO, "OFN_RESET", OFN_GPIO_OUT, OFN_GPIO_LOW, *ts->gpio_rst) < 0)
    {
        goto err_detect_failed;
    }
    else
    {
        // success to pull low reset pin, then to pull high.
        msleep(100);
        gpio_set_value( ts->gpio_rst, OFN_GPIO_HIGH);
        msleep(100);
    }
    #endif // AVAGO_RESET

    #ifdef AVAGO_GPIO_CONTROL_SHUTDOWN
    if ( avago_init_gpio( ts, AVAGO_SHUTDOWN_GPIO, "OFN SHUTDOWN", OFN_GPIO_OUT, OFN_GPIO_LOW, &ts->shutdown_gpio) < 0 )
        goto err_detect_failed;
    mdelay(100);        //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
    #endif // AVAGO_GPIO_CONTROL_SHUTDOWN

    //+++[ASD2_ES1|Jaco_Gao|2011.04.08] DOME in IRQ mode
    #ifndef DOME_IRQ_MODE

    // default behavior for DOME
    #ifdef AVAGO_DOME
    if( avago_init_gpio( ts, AVAGO_DOME_GPIO, "OFN GPIO DOME", OFN_GPIO_IN, NULL, &ts->dome_gpio) < 0)
        goto err_detect_failed;
    #endif // AVAGO_DOME

    #else   // else for ifdef DOME_IRQ_DOME
    
    // DOME in IRQ mode
    if ( avago_init_gpio( ts, AVAGO_DOME_GPIO, "OFN IRQ - DOME", OFN_GPIO_IN, OFN_GPIO_LOW, &ts->gpio_dome) == 0 )
    {
        ret = request_threaded_irq( TEGRA_GPIO_TO_IRQ(ts->gpio_dome),
                    avago_ts_irq_dome_handler,
                    avago_ts_irq_dome_thread,
                    IRQF_TRIGGER_FALLING,
                    "DOME IRQ",
                    ts);
        if( ret < 0 )
        {
            printk("%s:Fail to request IRQ %d for DOME\n",
                    __func__, TEGRA_GPIO_TO_IRQ(ts->gpio_dome));
            gpio_free(ts->gpio_dome);
        }
        else
        {
            ts->irq_dome = TEGRA_GPIO_TO_IRQ(ts->gpio_dome);
        }
        avago_ofn_init_irq_dome_timer(ts);
    }
    atomic_set( &ts->dome_status, NONE);
    #endif // end ifdef DOME_IRQ_MODE
    //---[ASD2_ES1|Jaco_Gao|2011.04.08] DOME in IRQ mode
    
    #ifdef AVAGO_LED_CONTROL
    if( (avago_init_gpio(ts, AVAGO_LED_UP, "OFN_LED_UP", OFN_GPIO_OUT, OFN_GPIO_LOW, &ts->led_up_gpio) < 0) ||
        (avago_init_gpio(ts, AVAGO_LED_DOWN, "OFN_LED_DOWN", OFN_GPIO_OUT, OFN_GPIO_LOW, &ts->led_down_gpio) < 0) )
        goto err_detect_failed;

    //avago_flash_led_multi(ts, 200, 0, 3);
    #endif // AVAGO_LED

    #ifdef JACO_FPD_TEST
    if ( avago_init_gpio( ts, TEGRA_GPIO_PK4, "OFN IRQ - FPD", OFN_GPIO_IN, NULL, &ts->gpio_fpd) < 0 )
        goto err_detect_failed;
    ret = request_irq( TEGRA_GPIO_TO_IRQ(gpio),
                avago_ts_irq_fpd_handler,
                IRQF_TRIGGER_RISING,
                "FPD IRQ" ,ts);
    if (ret < 0)
    {
        printk("Failt to request irq %d\n", TEGRA_GPIO_TO_IRQ(gpio));
    }
    #endif
    //---[ASD2_ES1|Jaco_Gao|2011.04.08] re-write GPIO init function
    
	pr_info("%s : GPIO config done\n",__func__);
	/* Perform soft reset by writing 0x5A to address 0x3A */
	avago_write_register_byte(ts->spi, 0x3A, 0x5A);
	/* wait for stabilize */
	msleep(100);
	
	ret = avago_read_register_byte(ts->spi, 0x0);
	if (ret != AVAGO_OFN_ID) {
		printk(KERN_ERR "avago TWI read failed\n");
		goto err_detect_failed;
	}
	else
		printk(KERN_INFO "avago_ofn_probe: Product Major Version %x\n", ret);
	

	ts->input_dev = input_allocate_device();
	if (ts->input_dev == NULL) {
		ret = -ENOMEM;
		printk(KERN_ERR "avago_ofn_probe: Failed to allocate input device\n");
		goto err_input_dev_alloc_failed;
	}
	
	ts->input_dev->name = "avago-pt";
	ts->input_dev->phys = "aofn/input0";
	ts->input_dev->id.bustype = BUS_HOST;
	ts->input_dev->id.vendor = 0x0001;
	ts->input_dev->id.product = 0x0001;
	ts->input_dev->id.version = 0x0100;

	ts->input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
	ts->input_dev->keycode = avago_keycode;
	ts->input_dev->keycodesize = sizeof(unsigned char);
	ts->input_dev->keycodemax = ARRAY_SIZE(avago_keycode);

    //+++[ASD2_ES1|Jaco_Gao|2011.04.11] modify i=1 to i=0
	for (i = 0; i < ARRAY_SIZE(avago_keycode); i++) {
		set_bit(avago_keycode[i], ts->input_dev->keybit);
	}

	ret = input_register_device(ts->input_dev);
	if (ret) {
		printk(KERN_ERR "avago_ofn_probe: "
				"Unable to register %s input device\n",
			ts->input_dev->name);
		goto err_input_register_device_failed;
	}
	
	printk(KERN_ERR "avago_ofn_probe: client irq %d\n", spi->irq);
	
	if (spi->irq) {
        //[ASD2_ES1|Jaco_Gao|2011.03.02] Enable interrupt
        gpio = TEGRA_IRQ_TO_GPIO(spi->irq);
        ret = gpio_request(gpio, "gpio_motion_int");
        if ( ret == 0 )
        {
            msleep(100);
            ret = gpio_direction_input(gpio);
            msleep(100);
            if( ret == 0 )
            {
                //[ASD2_ES1|Jaco_Gao|2011.03.02] Modify for insensitive problem
                //ret = request_irq(spi->irq, avago_ts_irq_handler, IRQF_TRIGGER_RISING,
                ret = request_irq(spi->irq, avago_ts_irq_handler, IRQF_TRIGGER_FALLING,
                        spi->dev.driver->name,ts);
                //[ASD2_ES1|Jaco_Gao|2011.03.02] Modify for insensitive problem
                if (ret == 0)
                    ts->use_irq = 1;
                else
                    dev_err(&spi->dev, "request_irq failed\n");
            }
            else
            {
                pr_err("avago_ofn : fail to direct gpio %d input\n", gpio);
                gpio_free(gpio);
            }
        }
        else
        {
            pr_err("avago_ofn : fail to request gpio %d for irq %d\n", gpio, spi->irq);
        }
        //[ASD2_ES1|Jaco_Gao|2011.03.02] Enable interrupt
	}
	if (!ts->use_irq) {
		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->timer.function = avago_ts_timer_func;
		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	}

    #ifndef DOME_IRQ_MODE       // ifdef DOME_IRQ_MODE --> in IRQ mode
	if (ts->dome_gpio) {
		hrtimer_init(&ts->dome_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->dome_timer.function = avago_dome_timer_func;
		//hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	}
    #endif

	ts->fpd_support = 0;	
#ifdef AVAGO_FPD	
	ts->fpd_support = 1;
#endif //AVAGO_FPD

	if (ts->fpd_support) {
		init_fpd(ts);

	}

#ifdef CONFIG_HAS_EARLYSUSPEND
	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
	ts->early_suspend.suspend = avago_ofn_early_suspend;
	ts->early_suspend.resume = avago_ofn_late_resume;
	register_early_suspend(&ts->early_suspend);
#endif

	printk(KERN_INFO "avago_ofn_probe: Start OFN %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");

	// initial the chip
	ret = avago_init_ofn(ts);

	att_mode = MODE_NORMAL;	
	// initial sysfs
	ofn_sysfs_init();

	g_ts = ts;		//+++[ASD2_ES1|Jaco_Gao|2011.03.29] for debug

    avago_ofn_init_led_timer(ts);       //+++[ASD2_ES1|Jaco_Gao|2011.04.18] Flash led by timer
    
	return 0;

err_input_register_device_failed:
	input_free_device(ts->input_dev);

err_input_dev_alloc_failed:
err_detect_failed:
//err_power_failed:
	kfree(ts);
err_alloc_data_failed:
//err_check_functionality_failed:
	return ret;
}

static int avago_ofn_remove(struct spi_device *spi)
{
	struct avago_ofn_data *ts = dev_get_drvdata(&spi->dev);
	//unregister_early_suspend(&ts->early_suspend);
	
	if(ts->shutdown_gpio)
		gpio_free(ts->shutdown_gpio);
	if(ts->dome_gpio)
		gpio_free(ts->dome_gpio);


	if (ts->use_irq)
		free_irq(spi->irq, ts);
	else
		hrtimer_cancel(&ts->timer);

    #ifndef DOME_IRQ_MODE
	if(ts->dome_gpio)
		hrtimer_cancel(&ts->dome_timer);
    #endif
	
	input_unregister_device(ts->input_dev);
	kfree(ts);
	return 0;
}


static int avago_ofn_suspend(struct spi_device *spi, pm_message_t mesg)
{
	int ret;
	struct avago_ofn_data *ts = dev_get_drvdata(&spi->dev);

    // Jaco : disable interrupt in early suspend
    #if 0
    //Sam test
	if (ts->use_irq)
		disable_irq(ts->irq);
	else
		hrtimer_cancel(&ts->timer);
    ret = cancel_work_sync(&ts->work);
    #endif
	
	/* Forces lowest power mode, same as asserting shutdown pin */
	if(ts->shutdown_gpio)
    {
		gpio_direction_output(ts->shutdown_gpio, 1);
        mdelay(150);        //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
    }

    #ifndef DOME_IRQ_MODE
	if(ts->dome_gpio)
		hrtimer_cancel(&ts->dome_timer);
    #endif

	if (ts->power) {
		ret = ts->power(0);
		if (ret < 0) {
			printk(KERN_ERR "%s: power off failed\n", __func__);
		}
	}
	return 0;
}

static int avago_ofn_resume(struct spi_device *spi)
{
	int ret;
	struct avago_ofn_data *ts = dev_get_drvdata(&spi->dev);

	if (ts->power) {
		ret = ts->power(1);
		if (ret < 0) {
			printk(KERN_ERR "%s: power on failed\n", __func__);
		}
	}
	/* reset, same effect as de-asserting shutdown pin. */
	if(ts->shutdown_gpio)
	{
		gpio_direction_output(ts->shutdown_gpio, 0);
        mdelay(100);        //+++[ASD2_ES1|Jaco_Gao|2011.04.20] add delay to fit OFN spec
		// initial the chip
		avago_init_ofn(ts);
	}

    // Jaco : re-enable interrupt in late resume
    #if 0
	if (ts->use_irq)
		enable_irq(spi->irq);
    else
    {
		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->timer.function = avago_ts_timer_func;
		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	}
    #endif

    #ifndef DOME_IRQ_MODE
	if (ts->dome_gpio) {
		hrtimer_init(&ts->dome_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->dome_timer.function = avago_dome_timer_func;
		
		ts->dome_count = 0;
	}
    #endif
	
	if (ts->fpd_support) {
		
		init_fpd(ts);
	}

	return 0;
}

#ifdef CONFIG_HAS_EARLYSUSPEND
static void avago_ofn_early_suspend(struct early_suspend *h)
{
	struct avago_ofn_data *ts;
	ts = container_of(h, struct avago_ofn_data, early_suspend);
    disable_irq(ts->irq);
    cancel_work_sync(&ts->work);

    //+++[ASD2_ES1|Jaco_Gao|2011.04.09] Add suspend/resume function for DOME IRQ MODE
    #ifdef DOME_IRQ_MODE
    disable_irq(ts->irq_dome);
    del_timer_sync(&ts->dome_irq_click_timer);
    atomic_set(&ts->dome_status, NONE);
    #endif
    //---[ASD2_ES1|Jaco_Gao|2011.04.09] Add suspend/resume function for DOME IRQ MODE
    //avago_ofn_suspend(ts->spi, PMSG_SUSPEND);
}

static void avago_ofn_late_resume(struct early_suspend *h)
{
	struct avago_ofn_data *ts;
	ts = container_of(h, struct avago_ofn_data, early_suspend);
    pr_info("+%s\n",__func__);
    //avago_ofn_resume(ts->spi);
    enable_irq(ts->irq);
    //+++[ASD2_ES1|Jaco_Gao|2011.04.09] Add suspend/resume function for DOME IRQ MODE
    #ifdef DOME_IRQ_MODE
    enable_irq(ts->irq_dome);
    #endif
    //---[ASD2_ES1|Jaco_Gao|2011.04.09] Add suspend/resume function for DOME IRQ MODE
    pr_info("-%s\n",__func__);
}
#endif

static struct spi_driver avago_ofn_driver = {
   .driver    = {
      .name   = "avago-ofn",
      .bus    = &spi_bus_type,
      .owner  = THIS_MODULE,
   },
   .probe   = avago_ofn_probe,
   .remove  = avago_ofn_remove,
    //#ifndef CONFIG_HAS_EARLYSUSPEND
   .suspend = avago_ofn_suspend,
   .resume	 = avago_ofn_resume,
    //#endif   
};


static int __init avago_ofn_init(void)
{
	avago_ofn_wq = create_singlethread_workqueue("avago_ofn_wq");
	if (!avago_ofn_wq)
		return -ENOMEM;
	return spi_register_driver(&avago_ofn_driver);
}

static void __exit avago_ofn_exit(void)
{
	if (avago_ofn_wq)
		destroy_workqueue(avago_ofn_wq);
	spi_unregister_driver(&avago_ofn_driver);
    kthread_stop(ofn_task);     //[ASD2-ES1|Soflen|2011.04.13] OFN event detection
}

module_init(avago_ofn_init);
module_exit(avago_ofn_exit);

MODULE_AUTHOR("Marcus J. <marcus.jie@avagotech.com>");
MODULE_DESCRIPTION("AVAGO OFN SPI DRIVER");
MODULE_LICENSE("GPL");
