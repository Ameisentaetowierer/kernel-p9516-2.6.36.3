/* drivers/input/touchscreen/avago_ofn.c
 *
 * Copyright (C) 2010 Avago Technologies. 
 *
 * This software is licensed under the terms of the GNU General Public
 * License version 2, as published by the Free Software Foundation, and
 * may be copied, distributed, and modified under those terms.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 */
#define DEBUG
#include <linux/module.h>
#include <linux/input.h>
#include <linux/interrupt.h>
#include <linux/spi/spi.h>
#include <linux/earlysuspend.h>
#include <linux/hrtimer.h>
#include <linux/platform_device.h>
//#include <linux/i2c.h>
#include <linux/delay.h>
#include "avago_ofn.h"
#include <linux/io.h>
#include <linux/gpio.h>
#include <mach/gpio.h>

#include <linux/time.h>
#include <linux/unistd.h>
#include <linux/delay.h>

#include <linux/mutex.h>		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition

// [ASD2-ES1|Chris Yang|2010.12.06] thread
#include <linux/kthread.h>
#define CLICK_TIME 150000000
#define BILLION  1000000000L
enum doubleClick
{
    non, click_one,click_one_up,click_two,click_two_up, overTime
} ;

/* AVAGO_RESET will driver NRST pin low then high to reset the chip */
//#define AVAGO_RESET
#define AVAGO_GPIO_CONTROL_SHUTDOWN
#define AVAGO_DOME
//#define AVAGO_FPD
#define AVAGO_LED_CONTROL

#define FPD_POLL_TIME	70 // 70ms

#define THIRTEEN_MA		0
#define FORTY_MA			1
#define FINGER_ON_THRESHOLD		12

#define I2C_M_WR				0
#define leswap(x) ( ((x << 8) & 0xff00) | ((x >> 8) & 0xff) )
#define MS_TO_NS(x) (x *1E6L)


// ADBM_A320 Register Addresses
#define ADBM_A320_PRODUCTID_ADDR         0x83
#define ADBM_A320_REVISIONID_ADDR        0x01     //0x00
#define ADBM_A320_MOTION_ADDR            0x02
#define ADBM_A320_DELTAX_ADDR            0x03
#define ADBM_A320_DELTAY_ADDR            0x04
#define ADBM_A320_SQUAL_ADDR             0x05
#define ADBM_A320_SHUTTERUPPER_ADDR      0x06
#define ADBM_A320_SHUTTERLOWER_ADDR      0x07
#define ADBM_A320_MAXIMUMPIXEL_ADDR      0x08
#define ADBM_A320_PIXELSUM_ADDR          0x09
#define ADBM_A320_MINIMUMPIXEL_ADDR      0x0A
#define ADBM_A320_PIXELGRAB_ADDR         0x0B
#define ADBM_A320_CRC0_ADDR              0x0C
#define ADBM_A320_CRC1_ADDR              0x0D
#define ADBM_A320_CRC2_ADDR              0x0E
#define ADBM_A320_CRC3_ADDR              0x0F
#define ADBM_A320_SELFTEST_ADDR          0x10
#define ADBM_A320_CONFIGURATIONBITS_ADDR 0x11
#define ADBM_A320_LED_CONTROL_ADDR       0x1A
#define ADBM_A320_IO_MODE_ADDR           0x1C
#define ADBM_A320_OBSERVATION_ADDR       0x2E
#define ADBM_A320_SOFTRESET_ADDR      	 0x3A     //0x5A
#define ADBM_A320_SHUTTER_MAX_HI_ADDR    0x3B
#define ADBM_A320_SHUTTER_MAX_LO_ADDR    0x3C
#define ADBM_A320_INVERSEREVISIONID_ADDR 0x3E     //0xFF
#define ADBM_A320_INVERSEPRODUCTID_ADDR  0x3F     //0x7C
typedef union
{
	uint16_t w;
	uint8_t b[2];
}
union16;

static struct workqueue_struct *avago_ofn_wq;

struct avago_ofn_platform_data {
	uint32_t version;
	int (*power)(int on);
};

struct avago_fpd_data {
	uint8_t motion2;
	uint8_t finger_on_counter;
	uint8_t finger_leave_counter;
	uint8_t FPD_turned_off;
	uint8_t shutter_values_captured;
	uint8_t last_state;
	uint16_t shutter_at_40ma;
	uint16_t shutter_at_13ma;
	uint8_t switch_led_counter;
};
	
struct avago_ofn_data {
	struct spi_device *spi;
	struct input_dev *input_dev;
	int use_irq;
	uint8_t irq;
	struct hrtimer timer;
	struct hrtimer dome_timer;
	struct work_struct  work;
	int shutdown_gpio;
	int dome_gpio;
	int led_up_gpio;
	int led_down_gpio;
	uint16_t dome_count;
	int motion_x;
	int motion_y;
	int motion_count;
	int key_pressed;
	int longMove;
	uint8_t fpd_support;
	struct avago_fpd_data fpd;
    struct task_struct  *task;    // [ASD2-ES1|Chris Yang|2010.12.06] thread task

    int pin_state ; // [ASD2-ES1|Chris Yang|2010.12.22] long press
	//uint8_t test_mode;
	
	int (*power)(int on);
	struct early_suspend early_suspend;

	struct mutex lock;		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
};

/* define a globle for easy porting */
static int test_mode = 0;

static unsigned char avago_keycode[] = {
	KEY_UP,
	KEY_DOWN,
	KEY_LEFT,
	KEY_RIGHT,
	KEY_HOME,
	KEY_MENU,
	KEY_BACK,
	KEY_A,
	KEY_B,
	KEY_C,
	KEY_D,
	KEY_E,
	KEY_F23,
	KEY_F24,
	KEY_SYSRQ
};	

#ifdef CONFIG_HAS_EARLYSUSPEND
static void avago_ofn_early_suspend(struct early_suspend *h);
static void avago_ofn_late_resume(struct early_suspend *h);
#endif
void outPutEvent(int,int,int,int,struct avago_ofn_data *);
int averageXY(int , int );

//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
u8 ofn_reg = 0;
int irq_status = 1;
int g_irq = 0;
static struct avago_ofn_data *g_ts;
static int thread_flag = 0;
int work_flag = 0;

static int ofn_thread(void *p);
static uint8_t avago_read_register_byte(struct spi_device *spi, u8 reg);
static int avago_write_register_byte(struct spi_device *spi, u8 reg, u8 val);
static int avago_init_ofn(struct avago_ofn_data *ts);
//--- [ASD2_ES1|Jaco_Gao|2011.03.29] for debug

static ssize_t ofn_mode_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

	if(test_mode)
		sprintf(buf, "Current mode is test mode.\n");
	else
		sprintf(buf, "Current mode is normal mode.\n");
		
	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_mode_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	char data[128];
	sscanf(buf, "%s", data);
	if(strcmp(data, "test") == 0)
	{
		test_mode = 1;
		printk(KERN_ERR "enter test mode\n");
	}
	if(strcmp(data, "normal") == 0)
	{
		test_mode = 0;
		printk(KERN_ERR "enter normal mode\n");
	}

	return count;
}

//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
static ssize_t ofn_reg_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int ret = 0;
	sprintf( buf, "OFN Reg. 0x%02x = 0x%02x\n", ofn_reg, avago_read_register_byte(g_ts->spi, ofn_reg) );
	ret = strlen(buf)+1;
	return ret;
}

static ssize_t ofn_reg_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	sscanf(buf, "%d", (int*)&ofn_reg);
	pr_info("Set ofn_reg = 0x%02x", ofn_reg);
	return count;
}

static ssize_t ofn_irq_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

	if(irq_status)
		sprintf(buf, "Current irq is enabled.\n");
	else
		sprintf(buf, "Current irq is disabled.\n");

	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_irq_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
	int val = 0;
	sscanf(buf, "%d", &val);

    switch( val )
    {
    case 0:
        disable_irq_nosync(g_irq);
        irq_status = 0;
    break;
    case 1:
        enable_irq(g_irq);
        irq_status = 1;
    break;
    default:
        return -EINVAL;
    }

	return count;
}

static ssize_t ofn_val_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    u8 val = 0;
    sscanf(buf, "%d", (int*)&val);
    avago_write_register_byte(g_ts->spi, ofn_reg, val);
    printk("OFN : write 0x%02x to Reg. 0x%02x\n", val, ofn_reg);
	return count;
}

static ssize_t ofn_reg_table_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
    int ret = 0;
    int i = 0;
    for( i = 0; i<= 0x77; i++)
        printk("Reg. 0x%02x = 0x%02x\n", i, avago_read_register_byte(g_ts->spi, i));

    return ret;
}

static ssize_t ofn_thread_flag_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

    sprintf(buf, "Current thread flag = %d\n", thread_flag);

	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_work_flag_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

    sprintf(buf, "Current work flag = %d\n", work_flag);

	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_reset_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    switch( *buf )
    {
    case '0':
        gpio_set_value(g_ts->shutdown_gpio, 1);
    break;
    case '1':
        gpio_set_value(g_ts->shutdown_gpio, 0);
    break;
    case '2':
        avago_init_ofn(g_ts);
    break;
    default:
        return -EINVAL;
    }

	return count;
}

static ssize_t ofn_thread_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    switch( *buf )
    {
    case '0':
        kthread_stop( g_ts->task );
    break;
    case '1':
        g_ts->task = kthread_create( ofn_thread , g_ts , "ofn_thread" );
        wake_up_process(g_ts->task);
    break;
    case '2':
        wake_up_process(g_ts->task);
    break;
    default:
        return -EINVAL;
    }

	return count;
}

static ssize_t ofn_status_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
    int ret;
    sprintf( buf, "OFN status = 0x%02x\n", avago_read_register_byte(g_ts->spi, 2) );
    ret = strlen(buf) + 1;
    return ret;
}

static ssize_t ofn_mutex_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	ssize_t ret = 0;

    sprintf(buf, "Mutex lock is %s\n", (mutex_is_locked(&g_ts->lock)?"ON":"OFF"));

	ret = strlen(buf) + 1;

	return ret;
}

static ssize_t ofn_mutex_store(struct device *dev, struct device_attribute *attr,
		const char *buf, size_t count)
{
    switch( *buf )
    {
    case '0':
        mutex_unlock(&g_ts->lock);
    break;
    case '1':
        printk("Mutex lock %s\n", (mutex_trylock( &g_ts->lock )?"Done":"Fail"));
    break;
    default:
        return -EINVAL;
    }

	return count;
}

static DEVICE_ATTR(mutex, S_IRUGO | S_IWUGO , ofn_mutex_show, ofn_mutex_store);
static DEVICE_ATTR(status, S_IRUGO , ofn_status_show, NULL);
static DEVICE_ATTR(thread, S_IWUGO, NULL, ofn_thread_store);
static DEVICE_ATTR(reset, S_IWUGO , NULL, ofn_reset_store);
static DEVICE_ATTR(thread_flag, S_IRUGO, ofn_thread_flag_show, NULL);
static DEVICE_ATTR(work_flag, S_IRUGO, ofn_work_flag_show, NULL);
static DEVICE_ATTR(reg_table, S_IRUGO , ofn_reg_table_show, NULL);
static DEVICE_ATTR(val, S_IWUGO , NULL, ofn_val_store);
static DEVICE_ATTR(reg, S_IWUGO|S_IRUGO, ofn_reg_show, ofn_reg_store);
static DEVICE_ATTR(irq, S_IWUGO|S_IRUGO, ofn_irq_show, ofn_irq_store);
//--- [ASD2_ES1|Jaco_Gao|2011.03.29] for debug

static DEVICE_ATTR(mode, S_IRUSR | S_IRGRP | S_IROTH, ofn_mode_show, ofn_mode_store);
static struct kobject *android_ofn_kobj;

//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
static struct attribute *attributes[] = {
        &dev_attr_mode.attr,
        &dev_attr_irq.attr,
        &dev_attr_mutex.attr,
        &dev_attr_thread.attr,
        &dev_attr_status.attr,
        &dev_attr_reset.attr,
        &dev_attr_reg.attr,
        &dev_attr_val.attr,
        &dev_attr_reg_table.attr,
        &dev_attr_thread_flag.attr,
        &dev_attr_work_flag.attr,
        NULL,
};
static struct attribute_group attribute_group = {
    .attrs = attributes,
};
//--- [ASD2_ES1|Jaco_Gao|2011.03.29] for debug

static int ofn_sysfs_init(void)
{
	int ret;
	android_ofn_kobj = kobject_create_and_add("ofn", NULL);
	if (android_ofn_kobj == NULL) {
		printk(KERN_ERR
		       "ofn_sysfs_init: subsystem_register failed\n");
		ret = -ENOMEM;
		goto err;
	}

	//ret = sysfs_create_file(android_ofn_kobj, &dev_attr_mode.attr);	//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	ret = sysfs_create_group( android_ofn_kobj, &attribute_group);		//+++ [ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	if (ret) {
		printk(KERN_ERR
		       "touch_sysfs_init: sysfs_create_group failed\n");
		goto error;
	}
	return 0;
error:
	kobject_del(android_ofn_kobj);
err:
	return ret;
}


static uint8_t avago_read_register_byte(struct spi_device *spi, u8 reg)
{
	int ret;
	u8 val;
	u8 code = reg;

	ret = spi_write_then_read(spi, &code, 1, &val, 1);

	if (ret < 0) {
		printk(KERN_ERR "spi read error reg:0x%X return:%d", reg, ret);
		return ret;
	}
	
	return val;
}
static int ofn_thread(void *p)
{

    struct avago_ofn_data *pdata = (struct avago_ofn_data*)p;

    uint8_t status = 0 ;

    enum doubleClick clickTemp = non ;
//#if 0     //[ASD2-ES1|Chris Yang|2010.12.22] Time stamp for key event
    struct timespec  start, end , doubleClickTime;
//#endif    //[ASD2-ES1|Chris Yang|2010.12.22] Time stamp for key event


    long accum = 0 ;
    bool mistake = false ;
    bool doubleTime = false ;
//  int clickTime = 0 ;             // jaco + for fix building warring
    int longPress = 0;  //[ASD2-ES1|Chris Yang|2010.12.22] Long press
    // int x = 0 , y = 0 ;
    //bool longPressHome = false ;
    //+++[ASD2-ES2|Chris|2011.03.23] add double click event SYSRQ
    while ( true )
    {
    	thread_flag = 0;
        //[ASD2_ES1|Jaco_Gao|2011.03.02] Fix resume error
        if( kthread_should_stop() )
        {
            pr_info("\nshould stop !!!\n\n");
            break;
        }
        //[ASD2_ES1|Jaco_Gao|2011.03.02] Fix resume error
        thread_flag = 1;
        //usleep(100);
        //+++[ASD-ES1|Chris Yang|2010.01.13] let cpu time out
        msleep(20);
        //---[ASD-ES1|Chris Yang|2010.01.13] let cpu time out
        thread_flag = 2;
        mutex_lock(&pdata->lock);		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
        thread_flag = 3;
        //printk("\nofn : flag 1\n");
        status = avago_read_register_byte(pdata->spi, 2);
        //printk("ofn : flag 2\n");
        thread_flag = 4;
        status &= 0x01 ;
        // printk("####################### status = %d \n", status );
        // clear garbage data
        // finger leave or not touch
		 // [ASD2-ES1|Chris Yang|2010.12.06] clear interrupt garbage
        if( status == 0 && ( pdata->motion_x != 0 || pdata->motion_y != 0 || pdata->motion_count != 0 ) )
        {

            pdata->motion_x = 0 ;
            pdata->motion_y = 0 ;
            pdata->motion_count = 0 ;
            clickTemp = non ;
            mistake = false ;
            pdata->longMove = 0 ;

        }
		// test double click
		if ( doubleTime == true )
		{
			end = current_kernel_time();
			accum = (long) ( ( end.tv_nsec - doubleClickTime.tv_nsec ) +  ( end.tv_sec - doubleClickTime.tv_sec ) * 1000000000L );
			// wait for too long second click
			// home key
			if ( accum > 300000000L)
			{
				if( test_mode != 2 )
                {

					input_report_key(pdata->input_dev, KEY_HOME, 1);
					input_sync(pdata->input_dev);
					input_report_key(pdata->input_dev, KEY_HOME, 0);
					input_sync(pdata->input_dev);
				}
				else
				{
					input_report_key(pdata->input_dev, KEY_C, 1);
					input_sync(pdata->input_dev);
					input_report_key(pdata->input_dev, KEY_C, 0);
					input_sync(pdata->input_dev);
					
				}
				pdata->pin_state = 0 ;
				doubleTime = false ;
				gpio_set_value(pdata->led_up_gpio,1);
				gpio_set_value(pdata->led_down_gpio,1);
				msleep(100);
				gpio_set_value(pdata->led_up_gpio,0);
				gpio_set_value(pdata->led_down_gpio,0);
			}
			
		}	
		thread_flag = 5;
        //+++[ASD2-ES1|Chris Yang|2010.12.22] add long press , click-> HOME key
        if( !gpio_get_value(pdata->dome_gpio))
        {
            if ( pdata->pin_state == 0 )
            {
                start = current_kernel_time();
                pdata->pin_state = 1 ;
                if (longPress == 0 )
                {
                    longPress = 1 ;
                }
            }
            // double click
            else if ( pdata->pin_state == 3 )
            {
				if( test_mode != 2 )
                {
					input_report_key(pdata->input_dev, KEY_SYSRQ, 1);
					input_sync(pdata->input_dev);
					input_report_key(pdata->input_dev, KEY_SYSRQ, 0);
					input_sync(pdata->input_dev);

				}
				else
				{
					input_report_key(pdata->input_dev, KEY_E, 1);
					input_sync(pdata->input_dev);
					input_report_key(pdata->input_dev, KEY_E, 0);
					input_sync(pdata->input_dev);
					
				}
				doubleTime =  false ;
				pdata->pin_state = 6 ;
				msleep(100);
				gpio_set_value(pdata->led_up_gpio,1);
				gpio_set_value(pdata->led_down_gpio,1);
				msleep(100);
				gpio_set_value(pdata->led_up_gpio,0);
				gpio_set_value(pdata->led_down_gpio,0);
				msleep(100);
				gpio_set_value(pdata->led_up_gpio,1);
				gpio_set_value(pdata->led_down_gpio,1);
				msleep(100);
				gpio_set_value(pdata->led_up_gpio,0);
				gpio_set_value(pdata->led_down_gpio,0);
				
			}
            else if ( pdata->pin_state == 1 )
            {
                end = current_kernel_time();
                accum = (long) ( ( end.tv_nsec - start.tv_nsec ) +  ( end.tv_sec - start.tv_sec ) * 1000000000L );
                
                if ( accum > 200000000L)
                {
					
					input_report_key(pdata->input_dev, KEY_HOME, 1);
					input_sync(pdata->input_dev);
					pdata->pin_state = 2 ;
				}               
            }
            else if ( pdata->pin_state == 2 )
            {
				end = current_kernel_time();
                accum = (long) ( ( end.tv_nsec - start.tv_nsec ) +  ( end.tv_sec - start.tv_sec ) * 1000000000L );
				if ( accum > 700000000L)
                {
                    // jaco + for test mode
                    if( test_mode != 2 )
                    {
                        // input_sync(pdata->input_dev);
                        input_report_key(pdata->input_dev, KEY_HOME, 0);
                        input_sync(pdata->input_dev);
                    }
                    else
                    {
                        input_report_key(pdata->input_dev, KEY_D, 1);
                        input_sync(pdata->input_dev);
                        input_report_key(pdata->input_dev, KEY_D, 0);
                        input_sync(pdata->input_dev);
                    }
                    msleep(100);
                    gpio_set_value(pdata->led_up_gpio,1);
				    gpio_set_value(pdata->led_down_gpio,1);
                    msleep(600);
                    gpio_set_value(pdata->led_up_gpio,0);
				    gpio_set_value(pdata->led_down_gpio,0);
                    pdata->pin_state = 6 ;
                    longPress = 0 ;
                    // jaco - for test mode
                }
			}
        }
        // up
        else
        {
            if ( pdata->pin_state == 1 )
            {
                doubleClickTime = current_kernel_time();
                doubleTime = true ;
                pdata->pin_state = 3 ;
            }
            else if ( pdata->pin_state == 2 )
            {
				input_report_key(pdata->input_dev, KEY_HOME, 0);
                input_sync(pdata->input_dev);
                pdata->pin_state = 6;
			} 
            if ( pdata->pin_state == 6 )
            {

                pdata->pin_state = 0 ;
                longPress = 0 ;
                doubleTime = false ;
            }
        }
        thread_flag = 6;
        mutex_unlock(&pdata->lock);		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
    } // end while
    //---[ASD2-ES2|Chris|2011.03.23] add double click event SYSRQ
    return 0 ;
}

static int avago_write_register_byte(struct spi_device *spi, u8 reg, u8 val)
{
	int ret_val;
	unsigned char buf[2];

	/* MSB must be '1' to indicate write */
	buf[0] = reg | 0x80;
	buf[1] = val;
	ret_val = spi_write_then_read(spi, buf, 2, NULL, 0);

	if(ret_val < 0)
	{
		printk(KERN_ERR "spi write error reg:0x%X return:%d", reg, ret_val);
	}
	return ret_val;
}



static int avago_init_ofn(struct avago_ofn_data *ts)
{
	int ret = 0;
	
	/* Perform soft reset by writing 0x5A to address 0x3A */
	avago_write_register_byte(ts->spi, 0x3A, 0x5A);
	
	/* init as datasheet required 
	Write 0xE4 to address 0x60.
	Set Speed Switching, write 0x62 with 0x12, 0x63 with 0x0E, 0x64 with 0x08, 0x65 with 0x06, 0x66 with 0x40, 0x67 with 0x08, 
		0x68 with 0x48, 0x69 with 0x0A, 0x6A with 0x50, 0x6B with 0x48.
	Set Assert/De-assert, write 0x6D with 0xC4, 0x6E with 0x34, 0x6F with 0x3C, 0x70 with 0x18, 0x71 with 0x20.
	Set Finger Presence Detection threshold, write 0x75 with 0x50.
	IF XY Quantization is used, then write 0x73 with 0x99 and 0x74 with 0x02.
	Write 0x10 to register 0x1C. This will activate Burst mode. If Burst mode not used then skip this step.
	Read from registers 0x02, 0x03 and 0x04 (or read these same 3 bytes with Burst mode) one time
	*/
	//avago_write_register_byte(ts->spi, 0x60, 0xE4);
	avago_write_register_byte(ts->spi, 0x60, 0xF4); 	/* enable quatitation */
	
	avago_write_register_byte(ts->spi, 0x62, 0x12);
	avago_write_register_byte(ts->spi, 0x63, 0x01); // YCC
	avago_write_register_byte(ts->spi, 0x64, 0x08);
	avago_write_register_byte(ts->spi, 0x65, 0x06);
	avago_write_register_byte(ts->spi, 0x66, 0x40);
	avago_write_register_byte(ts->spi, 0x67, 0x08);
	avago_write_register_byte(ts->spi, 0x68, 0x48);
	avago_write_register_byte(ts->spi, 0x69, 0x0A);
	avago_write_register_byte(ts->spi, 0x6A, 0x50);
	avago_write_register_byte(ts->spi, 0x6B, 0x48);
	
	avago_write_register_byte(ts->spi, 0x6D, 0xC4);
	avago_write_register_byte(ts->spi, 0x6E, 0x34);
	avago_write_register_byte(ts->spi, 0x6F, 0x3C);
	avago_write_register_byte(ts->spi, 0x70, 0x18);
	avago_write_register_byte(ts->spi, 0x71, 0x20);
	
	avago_write_register_byte(ts->spi, 0x75, 0x50);
	
	avago_write_register_byte(ts->spi, 0x73, 0x99);
	avago_write_register_byte(ts->spi, 0x74, 0x02);
	
	avago_read_register_byte(ts->spi, 0x2);
	avago_read_register_byte(ts->spi, 0x3);
	avago_read_register_byte(ts->spi, 0x4);

	ts->motion_count = 0;
	ts->motion_x = 0;
	ts->motion_y = 0;
	ts->key_pressed = 0;

	return ret;
}


static int init_fpd(struct avago_ofn_data *ts)
{
	struct avago_fpd_data *fpd;

	fpd = &ts->fpd;

	fpd->motion2 = 0;
	fpd->finger_on_counter = 0;
	fpd->finger_leave_counter = 0;
	fpd->FPD_turned_off = 0;
	fpd->shutter_values_captured = 0;
	fpd->last_state = THIRTEEN_MA;
	fpd->shutter_at_40ma = 0;
	fpd->shutter_at_13ma = 0;
	fpd->switch_led_counter = 0;

	return 0;
}
#ifdef AVAGO_FPD
static int switch_led_driving(struct avago_ofn_data *ts)
{
	struct avago_fpd_data *fpd;	
	union16 shutter1;

	fpd = &ts->fpd;
/*	
		// Once FPD is off, make sensor operate in 9.6mA. (~10mA)
		if (fpd->FPD_turned_off == 1)
		{	//force current during future navigation to be in 13mA
			//spi_write_sensor(0x1a,0x00);
			avago_write_register_byte(ts->spi, 0x1a, 0x00);

			fpd->last_state = THIRTEEN_MA;
			fpd->FPD_turned_off = 0;
			return 0;

		}
*/		
		//if ( (time_15 == 0) && (time_99 == 0) && (led_switching_start == 1) )
		{	// time_15 is the main timer for this loop.
			// time_99 is the timer for motion loop. This variable will gate this loop so that it 
			// will not start provided enough time has passed after there is no motion.
			//
			// [led_switching_start] : variable to keep track whether LED driving current 
			// switching is required. 
			// - When finger is moving, don't switch
			// - When finger is not moving, switching after time_99,
			// - When FPD is off, don't switch

			// read the shutter values
			//shutter1.b[0] = spi_read_sensor(ADBM_A320_SHUTTERUPPER_ADDR);
			//shutter1.b[1] = spi_read_sensor(ADBM_A320_SHUTTERLOWER_ADDR);
			shutter1.b[1] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERUPPER_ADDR);
			shutter1.b[0] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERLOWER_ADDR);
			//printk(KERN_INFO "shutter = %x \n", shutter1.w);
			
            		// If the last state is 40mA, switch to 13mA driving current
			if (fpd->last_state == FORTY_MA)
			{
				fpd->shutter_at_40ma = shutter1.w;
				//spi_write_sensor(0x1a,0x00);
				avago_write_register_byte(ts->spi, 0x1a, 0x00);
				fpd->last_state = THIRTEEN_MA;
			}

			// If the last state is 13mA, switch to 40mA driving current
			else if ( fpd->last_state == THIRTEEN_MA )
			{
				fpd->shutter_at_13ma = shutter1.w;
                		//spi_write_sensor(0x1a,0x03);
				avago_write_register_byte(ts->spi, 0x1a, 0x03);
				fpd->last_state = FORTY_MA;
			}

			// compare shutter ratio. uses *10 to take away decimal point comparison.
			// shutter_ratio = shutter_at_40ma *10 /shutter_at_13ma ;
			fpd->shutter_values_captured++;

			// fail safe check
			if (fpd->shutter_values_captured > 5)
			{ 
				fpd->shutter_values_captured = 0;
			}

		}

	return 0;
}
#endif

static void avago_ofn_work_func(struct work_struct *work)
{
    //[ASD2_ES1|Jaco_Gao|2011.03.02] Fix warning in building
    #if 0
//	int ret;
	char x, y, tempx, tempy;
	struct avago_ofn_data *ts = container_of(work, struct avago_ofn_data, work);
	uint8_t status, shutter_ratio;
	uint8_t pix_min, pix_max, squal;
	union16 shutter1;
	struct avago_fpd_data *fpd = &ts->fpd;
    #else
	char x, y;
	struct avago_ofn_data *ts = container_of(work, struct avago_ofn_data, work);
	uint8_t status;
    #endif
    //[ASD2_ES1|Jaco_Gao|2011.03.02] Fix warning in building
    work_flag = 0;
	mutex_lock(&ts->lock);		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
	work_flag = 1;
    pr_info("+%s\n",__func__);
	/* release the key */
	if(ts->key_pressed)
	{
		input_report_key(ts->input_dev, ts->key_pressed, 0);
		ts->key_pressed = 0;
					
		input_sync(ts->input_dev);
	}
	work_flag = 1;
#if 0
#ifdef AVAGO_DOME
	/* handle dome(single click/ long press) */
	if(ts->dome_count == 0)
	{
		if(!gpio_get_value(ts->dome_gpio))
		{
			ts->dome_count ++;
			printk(KERN_INFO "dome gpio down, count = %d\n", ts->dome_count);

//Sam test
			gpio_set_value(ts->led_up_gpio,1);
			gpio_set_value(ts->led_down_gpio,1);
			msleep(100);
			gpio_set_value(ts->led_down_gpio,0);
			gpio_set_value(ts->led_up_gpio,0);
			/* start timer, now is 5ms, adjust it for debounce */
			hrtimer_start(&ts->dome_timer, ktime_set(0, MS_TO_NS(5)), HRTIMER_MODE_REL);
			goto end_of_work_func;
		}
	}
	else
	{
		/* let timer handle dome function */
		goto end_of_work_func;
	}
#endif // AVAGO_DOME
#endif
    //printk("\nofn : flag 3\n");
	work_flag = 2;
    status = avago_read_register_byte(ts->spi, 2);
    work_flag = 3;
	//printk(KERN_ERR "motion = %x \n", status);
    //printk("ofn : flag 4\n");

#ifdef AVAGO_FPD
		// Once FPD is off, make sensor operate in 9.6mA. (~10mA)
		if (fpd->FPD_turned_off == 1)
		{	//force current during future navigation to be in 13mA
			//spi_write_sensor(0x1a,0x00);
			avago_write_register_byte(ts->spi, 0x1a, 0x00);

			fpd->last_state = THIRTEEN_MA;
			fpd->FPD_turned_off = 0;
		}

	fpd->motion2 = status;
	// motion2 is a variable to keep previously known FPD state in IC.		
	if((fpd->motion2 & 0x01) && (fpd->finger_on_counter < FINGER_ON_THRESHOLD) )
	{

		fpd->switch_led_counter++;
		if(fpd->switch_led_counter == 2)
		{
			switch_led_driving(ts);
			fpd->switch_led_counter = 0;
		}

		// method 1: change driving current
		if(fpd->shutter_values_captured == 2)
		{
			// Once two shutter values are captured, ratio of the two
			// can be compared to check for presence of a reflective surface
			shutter_ratio = fpd->shutter_at_40ma *10/fpd->shutter_at_13ma ;
			//printk(KERN_INFO "shutter_ratio = %d \n", shutter_ratio);

			if ( (shutter_ratio > 7) && (shutter_ratio < 14) )
			{	// if LED shutter value is between 0.9 and 1.2, 
				fpd->motion2 = fpd->motion2 & 0xFE;
				printk(KERN_INFO "shutter_ratio = %d \n", shutter_ratio);
			/*
			FPD_turned_off = 1;				// set FPD off flag
			L5 = !(motion2 & 0x01);			// show FPD status on LED
			finger_leave_counter2 = 0;
			finger_on_counter = 0;
			free_scroll = 0;	// Stop free scrolling mode if applicable
			*/
			}
			fpd->shutter_values_captured = 0;		// reset counter so shutter values can be recaptured.
		}

		// method 2
		squal   = avago_read_register_byte(ts->spi, ADBM_A320_SQUAL_ADDR);
		pix_min = avago_read_register_byte(ts->spi, ADBM_A320_MINIMUMPIXEL_ADDR);
		pix_max = avago_read_register_byte(ts->spi, ADBM_A320_MAXIMUMPIXEL_ADDR);
		shutter1.b[1] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERUPPER_ADDR);
		shutter1.b[0] = avago_read_register_byte(ts->spi, ADBM_A320_SHUTTERLOWER_ADDR);
		// shutter1.b[0] is lower byte of a 16 bit unsigned integer
		// shutter1.b[0] is upper byte of a 16 bit unsigned integer
		// shutter1.w is the combined 16 bit unsigned integer.
		//printk(KERN_INFO "squal = %x %x %x %x \n", squal, pix_min, pix_max, shutter1.w);
		
		//fpd->motion2 = status;
		//printk(KERN_ERR "motion = %x \n", status);

		// A comparison is done here to check is squal value is low (means finger is off),
		// If pix_max - pix_min is high, it tends to mean a strong external light source (point source) 
		// is present.
		// if shutter is low, it tends to mean an external light is shining directly into the sensor, 
		// and light reflected from sensor's LED cannot produce so might light.
		if ( (abs(pix_max - pix_min) > 230) || (squal < 15) || (shutter1.w < 25) )
		{	
			// finger_leave_counter is built in to reduce hysteresis effects
			// while finger is navigation smoothly, FPD may sometimes gets deactivated,
			// this reduces it. 
			if (fpd->finger_leave_counter >= 4)
			{	// finger_leave_counter is built in to reduce hysteresis effects
				// while finger is navigation smoothly, FPD may sometimes gets deactivated,
				// this reduces it. 
				printk(KERN_INFO "finger_leave_counter = %d \n", fpd->finger_leave_counter);

				fpd->motion2 = fpd->motion2 & 0xFE;
				/*
				FPD_turned_off = 1;
				finger_leave_counter = 0;
				finger_on_counter = 0; // reset finger on counter
				free_scroll = 0;	// Stop free scrolling mode if applicable
				*/
			}
			else
			{
				fpd->finger_leave_counter++;
			}

		}

		fpd->finger_on_counter++;
		//printk(KERN_INFO "fpd->finger_on_counter = %d \n", fpd->finger_on_counter);
		if (fpd->finger_on_counter == FINGER_ON_THRESHOLD) // 125 x 8ms = 1000ms
		{
			printk(KERN_INFO "finger on....\n\n");
			// ToDo
			// Light the led here to indicate finger touch
		}
		if (fpd->finger_on_counter > 150)
		{ fpd->finger_on_counter = 149;}
	}

		if((fpd->motion2 & 0x01) == 0)
		{
			if(fpd->finger_on_counter >= FINGER_ON_THRESHOLD)
			{
				printk(KERN_INFO "......finger off......\n\n");
				// ToDo
				// Turn off  the led here to indicate finger off
			}
			init_fpd(ts);
			fpd->FPD_turned_off = 1;
		}
		
#endif // AVAGO_FPD

	if(status & 0x80)
	{
		work_flag = 4;
		x = avago_read_register_byte(ts->spi, 3);
		work_flag = 5;
		y = avago_read_register_byte(ts->spi, 4);
		work_flag = 6;
		//printk(KERN_INFO "x = %x y = %x\n", x, y);

#ifdef AVAGO_FPD
		if((ts->fpd.motion2 & 0x01) == 0)
		{		
			ts->fpd.motion2 |= 1;
		
			printk(KERN_INFO "fpd start\n");
		}
#endif // AVAGO_FPD

		if( x != 0 || y != 0)
		{
			ts->motion_x += x;
			ts->motion_y += y;
		}
		
		if(ts->motion_count == 0)
			ts->motion_count = 1;
	}

	/* handle x/y motion */
	if(ts->motion_count > 0)
	{
       ts->motion_count++;

        if ( ts->motion_count == 2 ) // && ts->longMove == 0)
        {
            pr_debug("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(2,3,ts->motion_x,ts->motion_y,ts);

        }



        if ( ts->motion_count == 3  ) // && ts->longMove == 0)
        {
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(3,4,ts->motion_x,ts->motion_y,ts);
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d ",ts->motion_count,ts->motion_x,ts->motion_y );
        }
        else if ( ts->motion_count == 4 )
        {
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(4,5,ts->motion_x,ts->motion_y,ts);
        }
        else if(ts->motion_count > 5 && ts->motion_count <= 7 ) //  && ts->longMove == 0)
        {
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(ts->motion_count,7,ts->motion_x,ts->motion_y,ts);
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d ",ts->motion_count,ts->motion_x,ts->motion_y );
        }
        else if ( ts->motion_count > 7 && ts->motion_count <= 10)
        {
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(ts->motion_count,7,ts->motion_x,ts->motion_y,ts);
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d ",ts->motion_count,ts->motion_x,ts->motion_y );

        }
        else if ( ts->motion_count > 10  && ts->motion_count <= 14 )
        {
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n ",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(ts->motion_count,5,ts->motion_x,ts->motion_y,ts);
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d ",ts->motion_count,ts->motion_x,ts->motion_y );

        }
        else if ( ts->motion_count > 14  )
        {
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d \n",ts->motion_count,ts->motion_x,ts->motion_y );
            outPutEvent(ts->motion_count,3,ts->motion_x,ts->motion_y,ts);
//          printk("ts->motion_count = %d  ts->motion_x =  %d, ts->motion_y = %d ",ts->motion_count,ts->motion_x,ts->motion_y );

        }
	}
//[ASD2_ES1|Jaco_Gao|2011.03.02] fix for interrupt
//+++[ASD2_ES1|Jaco_Gao|2011.03.16] Disable irq before work function complete
#if 1
//end_of_work_func:
	work_flag = 7;
	mutex_unlock(&ts->lock);		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
	work_flag = 8;
	if (ts->use_irq)
	{
		work_flag = 9;
		enable_irq(ts->irq);
		work_flag = 10;
		irq_status = 1;				//+++[ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	}
#endif
//---[ASD2_ES1|Jaco_Gao|2011.03.16] Disable irq before work function complete
//[ASD2_ES1|Jaco_Gao|2011.03.02] fix for interrupt
    pr_info("-%s\n",__func__);
}
void eventType( int type, struct avago_ofn_data *ts )
{
    switch ( type )
    {
        case 3 :
                // jaco + for test mode
                if( test_mode != 2 )
                {
                        //+++[ASD2-ES1|Chris Yang|2010.12.27] change Key Event
                        //input_report_key(ts->input_dev, KEY_BACK, 1);
                        //ts->key_pressed = KEY_BACK;
                        //+++[ASD2_ES1|Jaco_Gao|2011.04.03] Modify key event for HC
                        #if 0
                        input_report_key(ts->input_dev, KEY_F23, 1); //+++[ASD-ES1|Chris Yang|2010.01.13] Change key event
                        ts->key_pressed = KEY_F23;
                        #else
                        input_report_key(ts->input_dev, KEY_BACK, 1); //+++[ASD-ES1|Chris Yang|2010.01.13] Change key event
                        ts->key_pressed = KEY_BACK;
                        #endif
                        //---[ASD2_ES1|Jaco_Gao|2011.04.03] Modify key event for HC
                        //---[ASD2-ES1|Chris Yang|2010.12.27] change Key Event
                }
                else
                {
                    // input_report_key(ts->input_dev, KEY_B, 1);
                    // ts->key_pressed = KEY_B;
                    input_report_key(ts->input_dev, KEY_A, 1);
                    ts->key_pressed = KEY_A;
                }
                // jaco - for test mode

                        //ofn_led_flash();
                        //msleep(100);
                        //ofn_led_flash();
                        input_sync(ts->input_dev);
    //                  ts->motion_count = 0 ;

                        input_report_key(ts->input_dev, ts->key_pressed, 0);
                        input_sync(ts->input_dev);
                        ts->key_pressed = 0 ;
                        pr_debug("case 3  longMove = %d \n", ts->longMove) ;
                        ts->longMove = 3 ;
/*
 * 
 * 			gpio_set_value(ts->led_up_gpio,1);
			gpio_set_value(ts->led_down_gpio,1);
			msleep(100);
			gpio_set_value(ts->led_down_gpio,0);
			gpio_set_value(ts->led_up_gpio,0);
 * 
 * 
 * 
 */

                        ts->motion_x = 0 ;
                        ts->motion_y = 0 ;
                        ts->motion_count = 3 ;

                        // Ofn_Set_Gpio(OFN_LED_UP , 1 );
                        gpio_set_value(ts->led_up_gpio,1);
                        msleep(100);
                        gpio_set_value(ts->led_up_gpio,0);
                        // Ofn_Set_Gpio(OFN_LED_UP , 0 );

                        break ;

        case 4 :
                // jaco + for test mode
                if( test_mode != 2 )
                {
                        //+++[ASD2-ES1|Chris Yang|2010.12.27] change Key Event
                        //input_report_key(ts->input_dev, KEY_MENU, 1);
                        //ts->key_pressed = KEY_MENU;
                        //+++[ASD2_ES1|Jaco_Gao|2011.04.03] Modify key event for HC
                        #if 0
                        input_report_key(ts->input_dev, KEY_F24, 1);//+++[ASD-ES1|Chris Yang|2010.01.13] Change key event
                        ts->key_pressed = KEY_F24;
                        #else
                        input_report_key(ts->input_dev, KEY_MENU, 1);//+++[ASD-ES1|Chris Yang|2010.01.13] Change key event
                        ts->key_pressed = KEY_MENU;
                        #endif
                        //---[ASD2_ES1|Jaco_Gao|2011.04.03] Modify key event for HC
                        //---[ASD2-ES1|Chris Yang|2010.12.27] change Key Event
                }
                else
                {
                    // input_report_key(ts->input_dev, KEY_A, 1);
                    // ts->key_pressed = KEY_A;
                    input_report_key(ts->input_dev, KEY_B, 1);
                    ts->key_pressed = KEY_B;
                }
                // jaco - for test mode
                        //ofn_led_flash();
                        input_sync(ts->input_dev);
    //                  ts->motion_count = 0 ;

                        input_report_key(ts->input_dev, ts->key_pressed, 0);
                        input_sync(ts->input_dev);
                        ts->key_pressed = 0 ;
                        printk("case 4  longMove = %d \n", ts->longMove) ;
                        ts->longMove = 4 ;
                        // Ofn_Set_Gpio(OFN_LED_DOWN , 1 );
                        gpio_set_value(ts->led_down_gpio,1);
                        msleep(100);
                        gpio_set_value(ts->led_down_gpio,0);
                        // Ofn_Set_Gpio(OFN_LED_DOWN , 0 );

                        ts->motion_x = 0 ;
                        ts->motion_y = 0 ;

                        ts->motion_count = 3 ;
                        break ;
                        //---[ASD2-ES1|Chris Yang|2010.12.22] OFN Definition


    }


}


void outPutEvent(int count , int totalMotion , int x , int y , struct avago_ofn_data *ts )
{
    //+++[ASD2-ES1|Chris Yang|2010.12.22] remove x scale
//  int tempx = averageXY( count , x );
    int tempy = averageXY( count , y );

/*
    if ( tempx >= (totalMotion  ))
    {


        if ( x & 0x80 )
        {
            eventType(1, ts );
        }
        else
        {
            eventType(2, ts );
        }


    }
    */
    //---[ASD2-ES1|Chris Yang|2010.12.22] remove x scale
    if ( tempy >= ( totalMotion+2 ) )
    {
        if ( y & 0x80 )
        {
            eventType(3, ts );
        }
        else
        {
            eventType(4, ts );
        }

    }




} // end outPutEvnet

int averageXY(int count, int x)
{
    int tempx ;

    if( x & 0x80 )
        tempx = (0x100 - (x & 0xff)) & 0xff;
    else
        tempx = x & (0xff) ;
        // tempx = x;

    pr_debug("tempx = %d , count = %d  , tempx/=count = %d \n ", tempx,count,tempx/count);
    tempx /= count ;
    return  tempx;

}

static enum hrtimer_restart avago_ts_timer_func(struct hrtimer *timer)
{
	struct avago_ofn_data *ts = container_of(timer, \
					struct avago_ofn_data, timer);
	queue_work(avago_ofn_wq, &ts->work);

	/* 8ms timer */
	hrtimer_start(&ts->timer, ktime_set(0, MS_TO_NS(8)), HRTIMER_MODE_REL);
	return HRTIMER_NORESTART;
}

static enum hrtimer_restart avago_dome_timer_func(struct hrtimer *timer)
{
	char gpio_value;
	struct avago_ofn_data *ts = container_of(timer, \
					struct avago_ofn_data, dome_timer);

	gpio_value = gpio_get_value(ts->dome_gpio);
	printk(KERN_INFO "gpio = %d, count = %d\n", gpio_value, ts->dome_count);

	if(gpio_value)
	{
		/* dome up, send report to upper layer */
		if(ts->dome_count == 1)
		{
			/* the first timer is 5ms to detect debouncing */
			printk(KERN_INFO "debounceing, gpio = %d\n", gpio_value);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
		else if(ts->dome_count <= DOME_SINGLE_CLICK_COUNT) //6
		{
			/* single click */
			if(test_mode)
			{
				input_report_key(ts->input_dev, KEY_HOME, 1);
				ts->key_pressed = KEY_HOME;
			}
			else
			{
				input_report_key(ts->input_dev, KEY_A, 1);
				ts->key_pressed = KEY_A;
			}
				
			printk(KERN_ERR "single click, count = %d\n", ts->dome_count);
									
			input_sync(ts->input_dev);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
		else if(ts->dome_count <= DOME_LONG_PRESS_COUNT) //21
		{
			/* long press */
			if(test_mode)
			{
				input_report_key(ts->input_dev, KEY_MENU, 1);
				ts->key_pressed = KEY_MENU;
			}
			else
			{
				input_report_key(ts->input_dev, KEY_B, 1);
				ts->key_pressed = KEY_B;
			}
			
			printk(KERN_ERR "long press, count = %d\n", ts->dome_count);
									
			input_sync(ts->input_dev);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
		else
		{
			printk(KERN_ERR "more than 2s, count = %d\n", ts->dome_count);
			ts->dome_count = 0;
			return HRTIMER_NORESTART;
		}
	}
	else
	{
		/* dome down, increase the counter */
		if(ts->dome_count < 0x80)	/* set the max value to avoid overflow */
			ts->dome_count++;
	}
		

	/* 100ms timer */
	hrtimer_start(&ts->dome_timer, ktime_set(0, MS_TO_NS(100)), HRTIMER_MODE_REL);
	return HRTIMER_NORESTART;
}

static irqreturn_t avago_ts_irq_handler(int irq, void *dev_id)
{
	struct avago_ofn_data *ts = dev_id;
    pr_info("+%s\n",__func__);
	/* printk("avago_ts_irq_handler\n"); */
	//disable_irq(ts->irq);                 //[ASD2_ES1|Jaco_Gao|2011.03.02] fix for interrupt
    disable_irq_nosync(ts->irq);            //[ASD2_ES1|Jaco_Gao|2011.03.16] Disable irq before work function complete
	irq_status = 0;							//+++[ASD2_ES1|Jaco_Gao|2011.03.29] for debug
    queue_work(avago_ofn_wq, &ts->work);
    pr_info("-%s\n",__func__);
	return IRQ_HANDLED;
}

static int __devinit avago_ofn_probe(struct spi_device *spi)
{
	struct avago_ofn_data *ts;
	int ret = 0, gpio, i;
//	struct avago_ofn_platform_data *pdata;

	printk(KERN_ERR "%s : init avago ofn\n", __func__);
	spi->bits_per_word = 8;
	spi->mode = SPI_MODE_3;
	if (spi_setup(spi) < 0) {
		printk(KERN_ERR "%s : init SPI failed.\n", __func__);
		ret = -ENODEV;
	}
	pr_info("%s : spi setup done\n",__func__);
	ts = kzalloc(sizeof(struct avago_ofn_data), GFP_KERNEL);
	if (ts == NULL) {
		ret = -ENOMEM;
		goto err_alloc_data_failed;
	}
	INIT_WORK(&ts->work, avago_ofn_work_func);
	mutex_init(&ts->lock);		//+++[ASD2_ES1|Jaco_Gao|20110329] Add mutex for prevent race condition
	ts->spi = spi;
	ts->irq = spi->irq;
	g_irq =  ts->irq;			//+++[ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	dev_set_drvdata(&spi->dev, ts);
/*	pdata = spi->dev.platform_data;
	if (pdata) {
		ts->power = pdata->power;
	}
	if (ts->power) {
		ret = ts->power(1);
		msleep(10);
		if (ret < 0) {
			printk(KERN_ERR "avago_ofn_probe power on failed\n");
			goto err_power_failed;
		}
	}
*/
#ifdef AVAGO_RESET
	/* Set NRST low then high */
	gpio = AVAGO_RESET_GPIO;
	ret = gpio_request(gpio, "gpio_ofn_reset");
	if (ret < 0) {
		printk(KERN_ERR "gpio_ofn_reset: failed to request GPIO %d,"
				" error %d\n", gpio, ret);
			goto err_detect_failed;
	}
	//Sam 
	//tegra_gpio_enable(gpio);	
	printk("gpio_ofn_reset:request GPIO= %d,"
                                " ret= %d\n", gpio, ret);	
	ret = gpio_direction_output(gpio, 0);
	if (ret < 0) {
		gpio_free(gpio);
		goto err_detect_failed;
	}
	msleep(100);
	
	ret = gpio_direction_output(gpio, 1);
	msleep(100);
	gpio_free(gpio);
#endif // AVAGO_RESET

	ts->shutdown_gpio = 0;
#ifdef AVAGO_GPIO_CONTROL_SHUTDOWN
	gpio = AVAGO_SHUTDOWN_GPIO;
	ret = gpio_request(gpio, "gpio_ofn_shutdown");
	if (ret < 0) {
		ts->shutdown_gpio = 0;
		printk(KERN_ERR "gpio_ofn_shutdown: failed to request GPIO %d,"
				" error %d\n", gpio, ret);
		goto err_detect_failed;
	}
	
	//tegra_gpio_enable(gpio);

	ret = gpio_direction_output(gpio, 0);
	
	printk("gpio_ofn_reset:request GPIO= %d,"" ret= %d\n", gpio, ret);
	if (ret < 0) {
		ts->shutdown_gpio = 0;
		gpio_free(gpio);
		goto err_detect_failed;
	}
	ts->shutdown_gpio = AVAGO_SHUTDOWN_GPIO;
#endif // AVAGO_GPIO_CONTROL_SHUTDOWN

	ts->dome_gpio = 0;
	ts->dome_count = 0;
#ifdef AVAGO_DOME
	gpio = AVAGO_DOME_GPIO;
	ret = gpio_request(gpio, "gpio_ofn_dome");
	if (ret < 0) {
		ts->dome_gpio = 0;
		printk(KERN_ERR "gpio_ofn_dome: failed to request GPIO %d,"
				" error %d\n", gpio, ret);
		goto err_detect_failed;
	}
	
	ret = gpio_direction_input(gpio);
	if (ret < 0) {
		ts->dome_gpio = 0;
		gpio_free(gpio);
		goto err_detect_failed;
	}
	ts->dome_gpio = AVAGO_DOME_GPIO;
#endif // AVAGO_DOME

    //Sam add led control
    ts->led_up_gpio = 0;
    ts->led_down_gpio = 0;
#ifdef AVAGO_LED_CONTROL
    gpio = AVAGO_LED_UP;
    ret = gpio_request(gpio, "gpio_led_up");
    if (ret < 0) {
        ts->dome_gpio = 0;
        printk(KERN_ERR "gpio_ofn_dome: failed to request GPIO %d,"
                " error %d\n", gpio, ret);
        goto err_detect_failed;
    }

    msleep(100);
    ret = gpio_direction_output(gpio,0);
	msleep(100);
    if (ret < 0) {
        ts->dome_gpio = 0;
        gpio_free(gpio);
        goto err_detect_failed;
    }
    ts->led_up_gpio = AVAGO_LED_UP;
	
    gpio = AVAGO_LED_DOWN;
    ret = gpio_request(gpio, "gpio_led_down");
    if (ret < 0) {
        ts->dome_gpio = 0;
        printk(KERN_ERR "gpio_ofn_dome: failed to request GPIO %d,"
                " error %d\n", gpio, ret);
        goto err_detect_failed;
    }
    
    msleep(100);
    ret = gpio_direction_output(gpio,0);
    msleep(100);
    if (ret < 0) {
        ts->dome_gpio = 0;
        gpio_free(gpio);
        goto err_detect_failed;
    }
    ts->led_down_gpio = AVAGO_LED_DOWN;
#endif // AVAGO_LED

	pr_info("%s : GPIO config done\n",__func__);
	/* Perform soft reset by writing 0x5A to address 0x3A */
	avago_write_register_byte(ts->spi, 0x3A, 0x5A);
	/* wait for stabilize */
	msleep(100);
	
	ret = avago_read_register_byte(ts->spi, 0x0);
	if (ret != AVAGO_OFN_ID) {
		printk(KERN_ERR "avago TWI read failed\n");
		goto err_detect_failed;
	}
	else
		printk(KERN_INFO "avago_ofn_probe: Product Major Version %x\n", ret);
	

	ts->input_dev = input_allocate_device();
	if (ts->input_dev == NULL) {
		ret = -ENOMEM;
		printk(KERN_ERR "avago_ofn_probe: Failed to allocate input device\n");
		goto err_input_dev_alloc_failed;
	}
	
	ts->input_dev->name = "avago-pt";
	ts->input_dev->phys = "aofn/input0";
	ts->input_dev->id.bustype = BUS_HOST;
	ts->input_dev->id.vendor = 0x0001;
	ts->input_dev->id.product = 0x0001;
	ts->input_dev->id.version = 0x0100;

	ts->input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP);
	ts->input_dev->keycode = avago_keycode;
	ts->input_dev->keycodesize = sizeof(unsigned char);
	ts->input_dev->keycodemax = ARRAY_SIZE(avago_keycode);

	for (i = 1; i < ARRAY_SIZE(avago_keycode); i++) {
		set_bit(avago_keycode[i], ts->input_dev->keybit);
	}

	ret = input_register_device(ts->input_dev);
	if (ret) {
		printk(KERN_ERR "avago_ofn_probe: "
				"Unable to register %s input device\n",
			ts->input_dev->name);
		goto err_input_register_device_failed;
	}
	
	printk(KERN_ERR "avago_ofn_probe: client irq %d\n", spi->irq);
	
	if (spi->irq) {
        //[ASD2_ES1|Jaco_Gao|2011.03.02] Enable interrupt
        gpio = TEGRA_IRQ_TO_GPIO(spi->irq);
        ret = gpio_request(gpio, "gpio_motion_int");
        if ( ret == 0 )
        {
            msleep(100);
            ret = gpio_direction_input(gpio);
            msleep(100);
            if( ret == 0 )
            {
                //[ASD2_ES1|Jaco_Gao|2011.03.02] Modify for insensitive problem
                //ret = request_irq(spi->irq, avago_ts_irq_handler, IRQF_TRIGGER_RISING,
                ret = request_irq(spi->irq, avago_ts_irq_handler, IRQF_TRIGGER_FALLING,
                        spi->dev.driver->name,ts);
                //[ASD2_ES1|Jaco_Gao|2011.03.02] Modify for insensitive problem
                if (ret == 0)
                    ts->use_irq = 1;
                else
                    dev_err(&spi->dev, "request_irq failed\n");
            }
            else
            {
                pr_err("avago_ofn : fail to direct gpio %d input\n", gpio);
                gpio_free(gpio);
            }
        }
        else
        {
            pr_err("avago_ofn : fail to request gpio %d for irq %d\n", gpio, spi->irq);
        }
        //[ASD2_ES1|Jaco_Gao|2011.03.02] Enable interrupt
	}
	if (!ts->use_irq) {
		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->timer.function = avago_ts_timer_func;
		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	}
	
	if (ts->dome_gpio) {
		hrtimer_init(&ts->dome_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->dome_timer.function = avago_dome_timer_func;
		//hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	}
// YCC
    ts->task = kthread_create( ofn_thread , ts , "ofn_thread" );
    ts->pin_state = 0 ;
    wake_up_process(ts->task);
// -- YCC
	ts->fpd_support = 0;	
#ifdef AVAGO_FPD	
	ts->fpd_support = 1;
#endif //AVAGO_FPD

	if (ts->fpd_support) {
		init_fpd(ts);

	}

#ifdef CONFIG_HAS_EARLYSUSPEND
	ts->early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 1;
	ts->early_suspend.suspend = avago_ofn_early_suspend;
	ts->early_suspend.resume = avago_ofn_late_resume;
	register_early_suspend(&ts->early_suspend);
#endif

	printk(KERN_INFO "avago_ofn_probe: Start OFN %s in %s mode\n", ts->input_dev->name, ts->use_irq ? "interrupt" : "polling");

	// initial the chip
	ret = avago_init_ofn(ts);

	test_mode = 0;	
	// initial sysfs
	ofn_sysfs_init();

	g_ts = ts;		//+++[ASD2_ES1|Jaco_Gao|2011.03.29] for debug
	
	return 0;

err_input_register_device_failed:
	input_free_device(ts->input_dev);

err_input_dev_alloc_failed:
err_detect_failed:
//err_power_failed:
	kfree(ts);
err_alloc_data_failed:
//err_check_functionality_failed:
	return ret;
}

static int avago_ofn_remove(struct spi_device *spi)
{
	struct avago_ofn_data *ts = dev_get_drvdata(&spi->dev);
	//unregister_early_suspend(&ts->early_suspend);
	
	if(ts->shutdown_gpio)
		gpio_free(ts->shutdown_gpio);
	if(ts->dome_gpio)
		gpio_free(ts->dome_gpio);


	if (ts->use_irq)
		free_irq(spi->irq, ts);
	else
		hrtimer_cancel(&ts->timer);

	if(ts->dome_gpio)
		hrtimer_cancel(&ts->dome_timer);
	
	input_unregister_device(ts->input_dev);
	kfree(ts);
	return 0;
}


static int avago_ofn_suspend(struct spi_device *spi, pm_message_t mesg)
{
	int ret;
	struct avago_ofn_data *ts = dev_get_drvdata(&spi->dev);
	//Sam test
	if (ts->use_irq)
		disable_irq(ts->irq);
	else
		hrtimer_cancel(&ts->timer);
	ret = cancel_work_sync(&ts->work);
	
	/* Forces lowest power mode, same as asserting shutdown pin */
	if(ts->shutdown_gpio)
		gpio_direction_output(ts->shutdown_gpio, 1);
	
	if(ts->dome_gpio)
		hrtimer_cancel(&ts->dome_timer);

	if (ts->power) {
		ret = ts->power(0);
		if (ret < 0) {
			printk(KERN_ERR "%s: power off failed\n", __func__);
		}
	}
	return 0;
}

static int avago_ofn_resume(struct spi_device *spi)
{
	int ret;
	struct avago_ofn_data *ts = dev_get_drvdata(&spi->dev);

	if (ts->power) {
		ret = ts->power(1);
		if (ret < 0) {
			printk(KERN_ERR "%s: power on failed\n", __func__);
		}
	}
	/* reset, same effect as de-asserting shutdown pin. */
	if(ts->shutdown_gpio)
	{
		gpio_direction_output(ts->shutdown_gpio, 0);
		// initial the chip
		avago_init_ofn(ts);
	}
	//Sam test
	if (ts->use_irq)
		enable_irq(spi->irq);

	if (!ts->use_irq) {
		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->timer.function = avago_ts_timer_func;
		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
	}
	
	if (ts->dome_gpio) {
		hrtimer_init(&ts->dome_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		ts->dome_timer.function = avago_dome_timer_func;
		
		ts->dome_count = 0;
	}
	
	if (ts->fpd_support) {
		
		init_fpd(ts);
	}

	return 0;
}

#ifdef CONFIG_HAS_EARLYSUSPEND
static void avago_ofn_early_suspend(struct early_suspend *h)
{
	struct avago_ofn_data *ts;
	//Sam test
	//kthread_stop(ts->task);
	ts = container_of(h, struct avago_ofn_data, early_suspend);
    //disable_irq(ts->irq);                                     //+++[ASD2_ES1|Jaco_Gao|2011.04.06] Fix bug in Suspend/Resume
    kthread_stop(ts->task);                                     //[ASD2_ES1|Jaco_Gao|2011.03.01] Workaround to fix error message while resume
    //avago_ofn_suspend(ts->spi, PMSG_SUSPEND);                 //+++[ASD2_ES1|Jaco_Gao|2011.04.06] Fix bug in Suspend/Resume
}

static void avago_ofn_late_resume(struct early_suspend *h)
{
	struct avago_ofn_data *ts;
	ts = container_of(h, struct avago_ofn_data, early_suspend);
    //[ASD2_ES1|Jaco_Gao|2011.03.01] Workaround to fix error message while resume
    pr_info("+%s\n",__func__);
    //kthread_stop(ts->task);
    //avago_ofn_resume(ts->spi);        //+++[ASD2_ES1|Jaco_Gao|2011.04.06] Fix bug in Suspend/Resume
    ts->task = kthread_create( ofn_thread , ts , "ofn_thread" );
    ts->pin_state = 0 ;
    wake_up_process(ts->task);
    //enable_irq(ts->irq);              //+++[ASD2_ES1|Jaco_Gao|2011.04.06] Fix bug in Suspend/Resume
    pr_info("-%s\n",__func__);
    //[ASD2_ES1|Jaco_Gao|2011.03.01] Workaround to fix error message while resume
}
#endif

static struct spi_driver avago_ofn_driver = {
   .driver    = {
      .name   = "avago-ofn",
      .bus    = &spi_bus_type,
      .owner  = THIS_MODULE,
   },
   .probe   = avago_ofn_probe,
   .remove  = avago_ofn_remove,
#ifndef CONFIG_HAS_EARLYSUSPEND
   .suspend = avago_ofn_suspend,
   .resume	 = avago_ofn_resume,
#endif   
};


static int __init avago_ofn_init(void)
{
	avago_ofn_wq = create_singlethread_workqueue("avago_ofn_wq");
	if (!avago_ofn_wq)
		return -ENOMEM;
	return spi_register_driver(&avago_ofn_driver);
}

static void __exit avago_ofn_exit(void)
{
	if (avago_ofn_wq)
		destroy_workqueue(avago_ofn_wq);
	spi_unregister_driver(&avago_ofn_driver);
}

module_init(avago_ofn_init);
module_exit(avago_ofn_exit);

MODULE_AUTHOR("Marcus J. <marcus.jie@avagotech.com>");
MODULE_DESCRIPTION("AVAGO OFN SPI DRIVER");
MODULE_LICENSE("GPL");
